use finite_wasm::Module;
use wasm_encoder as we;
use wasmparser as wp;

#[derive(thiserror::Error, Debug)]
pub(crate) enum Error {}

impl<'a> crate::test::TestContext {
    pub(crate) fn instrument(&self, module: &[u8], results: Module) -> Result<Vec<u8>, Error> {
        let mut output = wasm_encoder::Module::new();
        let mut new_type_section = we::TypeSection::new();
        let mut new_import_section = we::ImportSection::new();
        let mut instrument_fn_ty = None;
        let mut instrument_fn = None;
        let parser = wp::Parser::new(0);
        for payload in parser.parse_all(module) {
            let payload = payload.expect("module should already have been parsed successfully!");

            if instrument_fn_ty.is_none() && payload.as_section().map(|s| s.0 > 1).unwrap_or(false)
            {
                // We are about to parse a section that must come after the type section, but we
                // havenâ€™t seen a type section (ID = 1) yet, so we must create a new one.
                instrument_fn_ty = Some(new_type_section.len());
                new_type_section.function([we::ValType::I64], []);
                output.section(&new_type_section);
            }

            if instrument_fn.is_none() && payload.as_section().map(|s| s.0 > 2).unwrap_or(false) {
                // We are about to parse a section that must come after the import section, so it
                // is time to append the import section..
                let instrument_fn_ty =
                    instrument_fn_ty.expect("TODO: create type section if not present");
                instrument_fn = Some(new_import_section.len());
                new_import_section.import(
                    "spectest",
                    "finite_wasm_gas",
                    we::EntityType::Function(instrument_fn_ty),
                );
                new_import_section.import(
                    "spectest",
                    "finite_wasm_stack",
                    we::EntityType::Function(instrument_fn_ty),
                );
                output.section(&new_import_section);
            }

            match payload {
                // These two payload types are (re-)generated by wasm_encoder.
                wp::Payload::Version { .. } => {}
                wp::Payload::End(_) => {}
                wp::Payload::TypeSection(types) => {
                    for ty in types {
                        let ty = ty.expect("types should already have been parsed!");
                        match ty {
                            wp::Type::Func(f) => {
                                new_type_section.function(
                                    f.params().iter().copied().map(valtype),
                                    f.results().iter().copied().map(valtype),
                                );
                            }
                        }
                    }
                }
                wp::Payload::ImportSection(imports) => {
                    for import in imports {
                        let import = import.expect("imports should already have been parsed!");
                        let import_ty = match import.ty {
                            wp::TypeRef::Func(i) => we::EntityType::Function(i),
                            wp::TypeRef::Table(t) => we::EntityType::Table(we::TableType {
                                element_type: valtype(t.element_type),
                                minimum: t.initial,
                                maximum: t.maximum,
                            }),
                            wp::TypeRef::Memory(t) => we::EntityType::Memory(we::MemoryType {
                                minimum: t.initial,
                                maximum: t.maximum,
                                memory64: t.memory64,
                                shared: t.shared,
                            }),
                            wp::TypeRef::Global(t) => we::EntityType::Global(we::GlobalType {
                                val_type: valtype(t.content_type),
                                mutable: t.mutable,
                            }),
                            wp::TypeRef::Tag(t) => we::EntityType::Tag(we::TagType {
                                kind: match t.kind {
                                    wp::TagKind::Exception => we::TagKind::Exception,
                                },
                                func_type_idx: t.func_type_idx,
                            }),
                        };
                        new_import_section.import(import.module, import.name, import_ty);
                    }
                }
                wp::Payload::CodeSectionStart { count, range, size } => {
                    output.section(&wasm_encoder::RawSection {
                        id: 10,
                        data: &module[range],
                    });
                }
                wp::Payload::CodeSectionEntry(_) => {}
                _ => {
                    let (id, range) = payload
                        .as_section()
                        .expect("any non-section payloads should have been handled already");
                    output.section(&wasm_encoder::RawSection {
                        id,
                        data: &module[range],
                    });
                }
            }
        }

        Ok(output.finish())
    }
}

fn valtype(wp: wp::ValType) -> we::ValType {
    match wp {
        wp::ValType::I32 => we::ValType::I32,
        wp::ValType::I64 => we::ValType::I64,
        wp::ValType::F32 => we::ValType::F32,
        wp::ValType::F64 => we::ValType::F64,
        wp::ValType::V128 => we::ValType::V128,
        wp::ValType::FuncRef => we::ValType::FuncRef,
        wp::ValType::ExternRef => we::ValType::ExternRef,
    }
}
