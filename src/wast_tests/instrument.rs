use finite_wasm::{gas::InstrumentationKind, Module};
use wasm_encoder as we;
use wasmparser as wp;
use we::Section;

const PLACEHOLDER_FOR_NAMES: u8 = !0;
/// These function indices are known to be constant, as they are added at the beginning of the
/// imports section.
///
/// Doing so makes it much easier to transform references to other functions (basically add 2 to
/// all function indices)
const GAS_INSTRUMENTATION_FN: u32 = 0;

/// See [`GAS_INSTRUMENTATION_FN`].
const STACK_INSTRUMENTATION_FN: u32 = 1;

#[derive(thiserror::Error, Debug)]
pub(crate) enum Error {}

impl<'a> crate::test::TestContext {
    pub(crate) fn instrument(&self, module: &[u8], results: Module) -> Result<Vec<u8>, Error> {
        let mut output = wasm_encoder::Module::new();
        let mut new_type_section = we::TypeSection::new();
        let mut new_import_section = we::ImportSection::new();
        let mut new_code_section = we::CodeSection::new();
        let mut new_element_section = we::ElementSection::new();
        let mut new_export_section = we::ExportSection::new();
        let mut new_name_section = we::NameSection::new();
        let mut new_global_section = we::GlobalSection::new();
        let mut raw_sections = vec![];
        let section_placeholder = |id: u8| -> we::RawSection { we::RawSection { id, data: &[] } };
        let maybe_add_imports = |ts: &mut we::TypeSection, is: &mut we::ImportSection| {
            if is.is_empty() {
                let instrument_fn_ty = ts.len();
                // By adding the type at the end of the type section we guarantee that any other
                // type references remain valid.
                ts.function([we::ValType::I64], []);
                ts.function([we::ValType::I64, we::ValType::I64], []);
                // By inserting the imports at the beginning of the import section we make the new
                // function index mapping trivial (it is always just an increment by 2)
                is.import(
                    "spectest",
                    "finite_wasm_gas",
                    we::EntityType::Function(instrument_fn_ty),
                );
                is.import(
                    "spectest",
                    "finite_wasm_stack",
                    we::EntityType::Function(instrument_fn_ty + 1),
                );
            }
        };

        let parser = wp::Parser::new(0);
        for payload in parser.parse_all(module) {
            let payload = payload.expect("module should already have been parsed successfully!");
            match payload {
                // These two payload types are (re-)generated by wasm_encoder.
                wp::Payload::Version { .. } => {}
                wp::Payload::End(_) => {}
                // We must manually reconstruct the type and imports sections because we’re
                // appending elements to them.
                wp::Payload::TypeSection(types) => {
                    for ty in types {
                        let ty = ty.expect("types should already have been parsed!");
                        match ty {
                            wp::Type::Func(f) => {
                                new_type_section.function(
                                    f.params().iter().copied().map(valtype),
                                    f.results().iter().copied().map(valtype),
                                );
                            }
                        }
                    }
                }
                wp::Payload::ImportSection(imports) => {
                    maybe_add_imports(&mut new_type_section, &mut new_import_section);
                    for import in imports {
                        let import = import.expect("imports should already have been parsed!");
                        let import_ty = match import.ty {
                            wp::TypeRef::Func(i) => we::EntityType::Function(i),
                            wp::TypeRef::Table(t) => we::EntityType::Table(we::TableType {
                                element_type: valtype(t.element_type),
                                minimum: t.initial,
                                maximum: t.maximum,
                            }),
                            wp::TypeRef::Memory(t) => we::EntityType::Memory(we::MemoryType {
                                minimum: t.initial,
                                maximum: t.maximum,
                                memory64: t.memory64,
                                shared: t.shared,
                            }),
                            wp::TypeRef::Global(t) => we::EntityType::Global(we::GlobalType {
                                val_type: valtype(t.content_type),
                                mutable: t.mutable,
                            }),
                            wp::TypeRef::Tag(t) => we::EntityType::Tag(we::TagType {
                                kind: match t.kind {
                                    wp::TagKind::Exception => we::TagKind::Exception,
                                },
                                func_type_idx: t.func_type_idx,
                            }),
                        };
                        new_import_section.import(import.module, import.name, import_ty);
                    }
                }
                wp::Payload::StartSection { func, .. } => {
                    output.section(&we::StartSection {
                        function_index: func + 2,
                    });
                }
                wp::Payload::ElementSection(reader) => {
                    for elem in reader {
                        let elem = elem.expect("TODO");
                        let functions;
                        let expressions;
                        let offset;
                        let items = match elem.items {
                            wp::ElementItems::Functions(fns) => {
                                functions = fns
                                    .into_iter()
                                    .map(|v| v.expect("TODO") + 2)
                                    .collect::<Vec<_>>();
                                we::Elements::Functions(&functions)
                            }
                            wp::ElementItems::Expressions(exprs) => {
                                expressions = exprs
                                    .into_iter()
                                    .map(|v| constexpr(v.expect("TODO")))
                                    .collect::<Vec<_>>();
                                we::Elements::Expressions(&expressions)
                            }
                        };
                        new_element_section.segment(we::ElementSegment {
                            mode: match elem.kind {
                                wp::ElementKind::Passive => we::ElementMode::Passive,
                                wp::ElementKind::Declared => we::ElementMode::Declared,
                                wp::ElementKind::Active {
                                    table_index,
                                    offset_expr,
                                } => {
                                    offset = constexpr(offset_expr);
                                    we::ElementMode::Active {
                                        table: Some(table_index),
                                        offset: &offset,
                                    }
                                }
                            },
                            element_type: valtype(elem.ty),
                            elements: items,
                        });
                    }
                    raw_sections.push(section_placeholder(new_element_section.id()));
                }
                wp::Payload::CodeSectionStart { .. } => {
                    raw_sections.push(section_placeholder(new_code_section.id()));
                }
                wp::Payload::CodeSectionEntry(reader) => {
                    maybe_add_imports(&mut new_type_section, &mut new_import_section);
                    let locals = reader
                        .get_locals_reader()
                        .expect("TODO")
                        .into_iter()
                        .map(|v| v.map(|(c, t)| (c, valtype(t))))
                        .collect::<Result<Vec<_>, _>>()
                        .expect("TODO");
                    let mut new_function = we::Function::new(locals);
                    // Reserve the stack.
                    let code_idx = new_code_section.len() as usize;
                    new_function.instruction(&we::Instruction::I64Const(
                        results.function_operand_stack_sizes[code_idx] as i64,
                    ));
                    new_function.instruction(&we::Instruction::I64Const(
                        results.function_frame_sizes[code_idx] as i64,
                    ));
                    new_function.instruction(&we::Instruction::Call(STACK_INSTRUMENTATION_FN));
                    let gas_offsets = &results.gas_offsets[code_idx];
                    let gas_costs = &results.gas_costs[code_idx];
                    let gas_kinds = &results.gas_kinds[code_idx];

                    let mut instrumentation_points = gas_offsets
                        .iter()
                        .zip(gas_costs.iter())
                        .zip(gas_kinds.iter())
                        .peekable();

                    let mut operators = reader.get_operators_reader().expect("TODO");
                    while !operators.eof() {
                        let (op, offset) = operators.read_with_offset().expect("TODO");
                        let end_offset = operators.original_position();
                        if instrumentation_points.peek().map(|((o, _), _)| **o) == Some(offset) {
                            let ((_, g), k) = instrumentation_points.next().unwrap();
                            if !matches!(k, InstrumentationKind::Unreachable) && *g != 0 {
                                new_function.instruction(&we::Instruction::I64Const(*g as i64));
                                new_function
                                    .instruction(&we::Instruction::Call(GAS_INSTRUMENTATION_FN));
                            }
                        }
                        match op {
                            wp::Operator::RefFunc { function_index } => new_function
                                .instruction(&we::Instruction::RefFunc(function_index + 2)),
                            wp::Operator::Call { function_index } => {
                                new_function.instruction(&we::Instruction::Call(function_index + 2))
                            }
                            wp::Operator::ReturnCall { function_index } => {
                                new_function.instruction(&we::Instruction::Call(function_index + 2))
                            }
                            _ => new_function.raw(module[offset..end_offset].iter().copied()),
                        };
                    }
                    new_code_section.function(&new_function);
                }
                wp::Payload::ExportSection(reader) => {
                    for export in reader {
                        let export = export.expect("TODO");
                        let (kind, index) = match export.kind {
                            wp::ExternalKind::Func => (we::ExportKind::Func, export.index + 2),
                            wp::ExternalKind::Table => (we::ExportKind::Table, export.index),
                            wp::ExternalKind::Memory => (we::ExportKind::Memory, export.index),
                            wp::ExternalKind::Global => (we::ExportKind::Global, export.index),
                            wp::ExternalKind::Tag => (we::ExportKind::Tag, export.index),
                        };
                        new_export_section.export(export.name, kind, index);
                    }
                    raw_sections.push(section_placeholder(new_export_section.id()));
                }
                wp::Payload::GlobalSection(reader) => {
                    for global in reader {
                        let global = global.expect("TODO");
                        new_global_section.global(
                            we::GlobalType {
                                val_type: valtype(global.ty.content_type),
                                mutable: global.ty.mutable,
                            },
                            &constexpr(global.init_expr),
                        );
                    }
                    raw_sections.push(section_placeholder(new_global_section.id()));
                }
                wp::Payload::CustomSection(reader) if reader.name() == "name" => {
                    let names = wp::NameSectionReader::new(reader.data(), reader.data_offset());
                    for name in names {
                        let name = name.expect("TODO");
                        match name {
                            wp::Name::Module { name, .. } => new_name_section.module(name),
                            wp::Name::Function(map) => {
                                let mut new_name_map = namemap(map, true);
                                new_name_map.append(0, "finite_wasm_gas");
                                new_name_map.append(1, "finite_wasm_stack");
                                new_name_section.functions(&new_name_map)
                            }
                            wp::Name::Local(map) => new_name_section.locals(&indirectnamemap(map)),
                            wp::Name::Label(map) => new_name_section.labels(&indirectnamemap(map)),
                            wp::Name::Type(map) => new_name_section.types(&namemap(map, false)),
                            wp::Name::Table(map) => new_name_section.tables(&namemap(map, false)),
                            wp::Name::Memory(map) => {
                                new_name_section.memories(&namemap(map, false))
                            }
                            wp::Name::Global(map) => new_name_section.globals(&namemap(map, false)),
                            wp::Name::Element(map) => {
                                new_name_section.elements(&namemap(map, false))
                            }
                            wp::Name::Data(map) => new_name_section.data(&namemap(map, false)),
                            wp::Name::Unknown { .. } => {}
                        }
                    }
                    raw_sections.push(section_placeholder(PLACEHOLDER_FOR_NAMES));
                }
                // All the other sections are transparently copied over (they cannot reference a
                // function id, or we don’t know how to handle it anyhow)
                //
                _ => {
                    let (id, range) = payload
                        .as_section()
                        .expect("any non-section payloads should have been handled already");
                    raw_sections.push(wasm_encoder::RawSection {
                        id,
                        data: &module[range],
                    });
                }
            }
        }

        // The type and import sections always come first in a module. They may potentially be
        // preceded or interspersed by custom sections in the original module, so we’re just hoping
        // that the ordering doesn’t matter for tests…
        output.section(&new_type_section);
        output.section(&new_import_section);
        for section in raw_sections {
            match section.id {
                id if id == new_code_section.id() => output.section(&new_code_section),
                id if id == new_element_section.id() => output.section(&new_element_section),
                id if id == new_export_section.id() => output.section(&new_export_section),
                id if id == new_global_section.id() => output.section(&new_global_section),
                PLACEHOLDER_FOR_NAMES => output.section(&new_name_section),
                _ => output.section(&section),
            };
        }

        Ok(output.finish())
    }
}

fn valtype(wp: wp::ValType) -> we::ValType {
    match wp {
        wp::ValType::I32 => we::ValType::I32,
        wp::ValType::I64 => we::ValType::I64,
        wp::ValType::F32 => we::ValType::F32,
        wp::ValType::F64 => we::ValType::F64,
        wp::ValType::V128 => we::ValType::V128,
        wp::ValType::FuncRef => we::ValType::FuncRef,
        wp::ValType::ExternRef => we::ValType::ExternRef,
    }
}

fn constexpr(ep: wp::ConstExpr) -> we::ConstExpr {
    let mut reader = ep.get_binary_reader();
    match reader.clone().read_operator().expect("const operator") {
        wp::Operator::RefFunc { function_index } => we::ConstExpr::ref_func(function_index + 2),
        _ => {
            let expr_bytes = reader
                .read_bytes(reader.bytes_remaining())
                .expect("can't fail");
            // ConstExpr introduces its own `End` operand, so we want want to drop it.
            let without_end = &expr_bytes[0..expr_bytes.len() - 1];
            we::ConstExpr::raw(without_end.iter().copied())
        }
    }
}

fn namemap(p: wp::NameMap, is_function: bool) -> we::NameMap {
    let mut new_name_map = we::NameMap::new();
    for naming in p {
        let naming = naming.expect("TODO");
        new_name_map.append(naming.index + (2u32 * is_function as u32), naming.name);
    }
    new_name_map
}

fn indirectnamemap(p: wp::IndirectNameMap) -> we::IndirectNameMap {
    let mut new_name_map = we::IndirectNameMap::new();
    for naming in p {
        let naming = naming.expect("TODO");
        new_name_map.append(naming.index + 2, &namemap(naming.names, false));
    }
    new_name_map
}
