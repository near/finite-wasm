# [Execution](https://www.w3.org/TR/wasm-core-1/#execution%E2%91%A1)

The specific mechanism to instrument a WebAssembly module is implementation-specific. This section
describes the extensions to the [execution
semantics](https://www.w3.org/TR/wasm-core-1/#execution%E2%91%A1) of an instrumented WebAssembly
module.

The specification extensions allow for various implementation strategies, including but not limited
to: transforming the WASM code to VM agnostic instrumented WASM code; built-in accounting in the VM
implementation itself; and others.

## [Runtime Structure](https://www.w3.org/TR/wasm-core-1/#runtime-structure%E2%91%A0)

### [Module Instances](https://www.w3.org/TR/wasm-core-1/#module-instances%E2%91%A0)

The `moduleinst` record is extended with the following entries:

* An amount of gas remaining `u64 gas`;
* Limit to the number of stack entries `u32 stacklimit`.

These additional entries may be emulated via instances of mutable global variables, if necessary.

### [Stack](https://www.w3.org/TR/wasm-core-1/#stack%E2%91%A0)

“Stack height” is the height of the implicit stack. Stack height is a sum of:

1. The sum of sizes of the `value` stack entries; and
2. The sum of sizes of the `label` stack entries; and
3. The sum of sizes of the function activation frame stack entries.

**Note:** The size of each type of entry is not specified by this specification, however there are
some considerations to make when deciding on a function to compute the size of an entry:

* It may make sense to count each `value` as `1` slot or, alternatively, to consider their byte
  size (e.g. 4 for `i32` and 8 for `i64`);
* `labels` may be counted as `0` or `1` entry depending on the way they’re handled;
* In addition to the size inherent to all `activation` frames, the sizes of all local `value`s in
  `activation.frame.val` should be considered, as they may increase the size of the activation
  frames on the stack significantly.

## [Instructions]()

Executing any individual instruction decreases the `F.module.gas` by a some predetermined amount
`fee(insn)`. If subtracting the `fee(insn)` would cause `F.module.gas` to decrease below zero, or
to overflow, `F.module.gas` is set to 0 and the execution `trap`s.

**Note:** Specifying the mapping between `insn` and `fee(insn)` is a responsibility of the embedder
and is out of scope for this specification.

**Note:** Instructions may decrease gas based on the operands the instruction would consume. This
is particularly useful for bulk instructions such as `memory.grow`.

### [Function calls]()

#### [Invocation of function address a]()

Executing an instruction that invokes function instances must additionally:

* Decrease the `F.module.gas` by `fee(t.const 0)` for each function local in `f.code.locals`. This
  charges the gas fees necessary to produce a list of 0-values and to push the function activation
  frame `F` onto the stack. If subtracting the fee would cause `F.module.gas` to decrease below
  zero or to overflow, `F.module.gas` is set to 0 and the execution `trap`s.

<!--
TODO: should this have a separate pseudo-instruction for this instead of piggy-backing on
`t.const`?
-->

<!--
TODO:

#### [Host functions]()

Should we charge fees before calling out to a host function? Should this be a part of the spec?
-->

## [Modules](https://www.w3.org/TR/wasm-core-1/#modules%E2%91%A5)

### [Instantiation]()

`moduleinst.gas` and `moduleinst.stacklimit` are initialized to their initial values during the
module allocation. This must occur before any instructions are evaluated as part of the
instantiation process.

### [Invocation](https://www.w3.org/TR/wasm-core-1/#invocation%E2%91%A1)

The external invocation of an exported function is augmented with the following operations:

0. Assert: Stack height is 0, before any stack operations occur.
9. Before function invocation:
  * Charge gas for each local of `funcaddr` and execution of this `call` instruction;

**Note**: Instrumentation may implement this via the export indirection mechanism specified in an
appendix, however implementations are required to _not_ utilize stack indirection if they implement
this behaviour in some other manner, as this may lead to double-charging.

## Other

Every time the implicit stack is modified by pushing to or popping from it, the runtime must ensure
that the resulting stack’s height does not exceed the `stacklimit` specified in the `F.module` and
`trap` otherwise.
