(module
  (type (;0;) (func (param f64 f64 f64) (result f64)))
  (type (;1;) (func (param i64)))
  (type (;2;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 1)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 2)))
  (func (;2;) (type 0) (param $x f64) (param $y f64) (param $z f64) (result f64)
    i64.const 16
    i64.const 2
    call 1
    i64.const 6
    call 0
    local.get $x
    local.get $y
    f64.mul
    local.get $z
    f64.add
  )
  (export "f64.no_contraction" (func 2))
)
(assert_return (invoke "f64.no_contraction" (f64.const -0x1.9e87ce14273afp-103) (f64.const 0x1.2515ad31db63ep+664) (f64.const 0x1.868c6685e6185p+533)) (f64.const -0x1.da94885b11493p+561))
(assert_return (invoke "f64.no_contraction" (f64.const 0x1.da21c460a6f44p+52) (f64.const 0x1.60859d2e7714ap-321) (f64.const 0x1.e63f1b7b660e1p-302)) (f64.const 0x1.4672f256d1794p-268))
(assert_return (invoke "f64.no_contraction" (f64.const -0x1.f3eaf43f327cp-594) (f64.const 0x1.dfcc009906b57p+533) (f64.const 0x1.5984e03c520a1p-104)) (f64.const -0x1.d4797fb3db166p-60))
(assert_return (invoke "f64.no_contraction" (f64.const 0x1.dab6c772cb2e2p-69) (f64.const -0x1.d761663679a84p-101) (f64.const 0x1.f22f92c843226p-218)) (f64.const -0x1.b50d72dfcef68p-169))
(assert_return (invoke "f64.no_contraction" (f64.const -0x1.87c5def1e4d3dp-950) (f64.const -0x1.50cd5dab2207fp+935) (f64.const 0x1.e629bd0da8c5dp-54)) (f64.const 0x1.01b6feb4e78a7p-14))

;; Test that x*y+z is not folded to fma.

(module
  (type (;0;) (func (param f32 f32 f32) (result f32)))
  (type (;1;) (func (param f64 f64 f64) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (param $y f32) (param $z f32) (result f32)
    i64.const 8
    i64.const 2
    call 1
    i64.const 6
    call 0
    local.get $x
    local.get $y
    f32.mul
    local.get $z
    f32.add
  )
  (func (;3;) (type 1) (param $x f64) (param $y f64) (param $z f64) (result f64)
    i64.const 16
    i64.const 2
    call 1
    i64.const 6
    call 0
    local.get $x
    local.get $y
    f64.mul
    local.get $z
    f64.add
  )
  (export "f32.no_fma" (func 2))
  (export "f64.no_fma" (func 3))
)
(assert_return (invoke "f32.no_fma" (f32.const 0x1.a78402p+124) (f32.const 0x1.cf8548p-23) (f32.const 0x1.992adap+107)) (f32.const 0x1.a5262cp+107))
(assert_return (invoke "f32.no_fma" (f32.const 0x1.ed15a4p-28) (f32.const -0x1.613c72p-50) (f32.const 0x1.4757bp-88)) (f32.const -0x1.5406b8p-77))
(assert_return (invoke "f32.no_fma" (f32.const 0x1.ae63a2p+37) (f32.const 0x1.b3a59ap-13) (f32.const 0x1.c16918p+10)) (f32.const 0x1.6e385cp+25))
(assert_return (invoke "f32.no_fma" (f32.const 0x1.2a77fap-8) (f32.const -0x1.bb7356p+22) (f32.const -0x1.32be2ap+1)) (f32.const -0x1.0286d4p+15))
(assert_return (invoke "f32.no_fma" (f32.const 0x1.298fb6p+126) (f32.const -0x1.03080cp-70) (f32.const -0x1.418de6p+34)) (f32.const -0x1.2d15c6p+56))
(assert_return (invoke "f64.no_fma" (f64.const 0x1.ac357ff46eed4p+557) (f64.const 0x1.852c01a5e7297p+430) (f64.const -0x1.05995704eda8ap+987)) (f64.const 0x1.855d905d338ep+987))
(assert_return (invoke "f64.no_fma" (f64.const 0x1.e2fd6bf32010cp+749) (f64.const 0x1.01c2238d405e4p-130) (f64.const 0x1.2ecc0db4b9f94p+573)) (f64.const 0x1.e64eb07e063bcp+619))
(assert_return (invoke "f64.no_fma" (f64.const 0x1.92b7c7439ede3p-721) (f64.const -0x1.6aa97586d3de6p+1011) (f64.const 0x1.8de4823f6358ap+237)) (f64.const -0x1.1d4139fd20ecdp+291))
(assert_return (invoke "f64.no_fma" (f64.const -0x1.466d30bddb453p-386) (f64.const -0x1.185a4d739c7aap+443) (f64.const 0x1.5f9c436fbfc7bp+55)) (f64.const 0x1.bd61a350fcc1ap+57))
(assert_return (invoke "f64.no_fma" (f64.const 0x1.7e2c44058a799p+52) (f64.const 0x1.c73b71765b8b2p+685) (f64.const -0x1.16c641df0b108p+690)) (f64.const 0x1.53ccb53de0bd1p+738))

;; Test that x+0.0 is not folded to x.
;; See IEEE 754-2008 10.4 "Literal meaning and value-changing optimizations".

(module
  (type (;0;) (func (param f32) (result f32)))
  (type (;1;) (func (param f64) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (result f32)
    i64.const 8
    i64.const 0
    call 1
    i64.const 4
    call 0
    local.get $x
    f32.const 0x0p+0 (;=0;)
    f32.add
  )
  (func (;3;) (type 1) (param $x f64) (result f64)
    i64.const 16
    i64.const 0
    call 1
    i64.const 4
    call 0
    local.get $x
    f64.const 0x0p+0 (;=0;)
    f64.add
  )
  (export "f32.no_fold_add_zero" (func 2))
  (export "f64.no_fold_add_zero" (func 3))
)
(assert_return (invoke "f32.no_fold_add_zero" (f32.const -0.0)) (f32.const 0.0))
(assert_return (invoke "f64.no_fold_add_zero" (f64.const -0.0)) (f64.const 0.0))
(assert_return (invoke "f32.no_fold_add_zero" (f32.const nan:0x200000)) (f32.const nan:arithmetic))
(assert_return (invoke "f64.no_fold_add_zero" (f64.const nan:0x4000000000000)) (f64.const nan:arithmetic))

;; Test that 0.0 - x is not folded to -x.

(module
  (type (;0;) (func (param f32) (result f32)))
  (type (;1;) (func (param f64) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (result f32)
    i64.const 8
    i64.const 0
    call 1
    i64.const 4
    call 0
    f32.const 0x0p+0 (;=0;)
    local.get $x
    f32.sub
  )
  (func (;3;) (type 1) (param $x f64) (result f64)
    i64.const 16
    i64.const 0
    call 1
    i64.const 4
    call 0
    f64.const 0x0p+0 (;=0;)
    local.get $x
    f64.sub
  )
  (export "f32.no_fold_zero_sub" (func 2))
  (export "f64.no_fold_zero_sub" (func 3))
)
(assert_return (invoke "f32.no_fold_zero_sub" (f32.const 0.0)) (f32.const 0.0))
(assert_return (invoke "f64.no_fold_zero_sub" (f64.const 0.0)) (f64.const 0.0))
(assert_return (invoke "f32.no_fold_zero_sub" (f32.const nan:0x200000)) (f32.const nan:arithmetic))
(assert_return (invoke "f64.no_fold_zero_sub" (f64.const nan:0x4000000000000)) (f64.const nan:arithmetic))

;; Test that x - 0.0 is not folded to x.

(module
  (type (;0;) (func (param f32) (result f32)))
  (type (;1;) (func (param f64) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (result f32)
    i64.const 8
    i64.const 0
    call 1
    i64.const 4
    call 0
    local.get $x
    f32.const 0x0p+0 (;=0;)
    f32.sub
  )
  (func (;3;) (type 1) (param $x f64) (result f64)
    i64.const 16
    i64.const 0
    call 1
    i64.const 4
    call 0
    local.get $x
    f64.const 0x0p+0 (;=0;)
    f64.sub
  )
  (export "f32.no_fold_sub_zero" (func 2))
  (export "f64.no_fold_sub_zero" (func 3))
)
(assert_return (invoke "f32.no_fold_sub_zero" (f32.const nan:0x200000)) (f32.const nan:arithmetic))
(assert_return (invoke "f64.no_fold_sub_zero" (f64.const nan:0x4000000000000)) (f64.const nan:arithmetic))

;; Test that x*0.0 is not folded to 0.0.

(module
  (type (;0;) (func (param f32) (result f32)))
  (type (;1;) (func (param f64) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (result f32)
    i64.const 8
    i64.const 0
    call 1
    i64.const 4
    call 0
    local.get $x
    f32.const 0x0p+0 (;=0;)
    f32.mul
  )
  (func (;3;) (type 1) (param $x f64) (result f64)
    i64.const 16
    i64.const 0
    call 1
    i64.const 4
    call 0
    local.get $x
    f64.const 0x0p+0 (;=0;)
    f64.mul
  )
  (export "f32.no_fold_mul_zero" (func 2))
  (export "f64.no_fold_mul_zero" (func 3))
)
(assert_return (invoke "f32.no_fold_mul_zero" (f32.const -0.0)) (f32.const -0.0))
(assert_return (invoke "f32.no_fold_mul_zero" (f32.const -1.0)) (f32.const -0.0))
(assert_return (invoke "f32.no_fold_mul_zero" (f32.const -2.0)) (f32.const -0.0))
(assert_return (invoke "f32.no_fold_mul_zero" (f32.const nan:0x200000)) (f32.const nan:arithmetic))
(assert_return (invoke "f64.no_fold_mul_zero" (f64.const -0.0)) (f64.const -0.0))
(assert_return (invoke "f64.no_fold_mul_zero" (f64.const -1.0)) (f64.const -0.0))
(assert_return (invoke "f64.no_fold_mul_zero" (f64.const -2.0)) (f64.const -0.0))
(assert_return (invoke "f64.no_fold_mul_zero" (f64.const nan:0x4000000000000)) (f64.const nan:arithmetic))

;; Test that x*1.0 is not folded to x.
;; See IEEE 754-2008 10.4 "Literal meaning and value-changing optimizations".

(module
  (type (;0;) (func (param f32) (result f32)))
  (type (;1;) (func (param f64) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (result f32)
    i64.const 8
    i64.const 0
    call 1
    i64.const 4
    call 0
    local.get $x
    f32.const 0x1p+0 (;=1;)
    f32.mul
  )
  (func (;3;) (type 1) (param $x f64) (result f64)
    i64.const 16
    i64.const 0
    call 1
    i64.const 4
    call 0
    local.get $x
    f64.const 0x1p+0 (;=1;)
    f64.mul
  )
  (export "f32.no_fold_mul_one" (func 2))
  (export "f64.no_fold_mul_one" (func 3))
)
(assert_return (invoke "f32.no_fold_mul_one" (f32.const nan:0x200000)) (f32.const nan:arithmetic))
(assert_return (invoke "f64.no_fold_mul_one" (f64.const nan:0x4000000000000)) (f64.const nan:arithmetic))

;; Test that 0.0/x is not folded to 0.0.

(module
  (type (;0;) (func (param f32) (result f32)))
  (type (;1;) (func (param f64) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (result f32)
    i64.const 8
    i64.const 0
    call 1
    i64.const 4
    call 0
    f32.const 0x0p+0 (;=0;)
    local.get $x
    f32.div
  )
  (func (;3;) (type 1) (param $x f64) (result f64)
    i64.const 16
    i64.const 0
    call 1
    i64.const 4
    call 0
    f64.const 0x0p+0 (;=0;)
    local.get $x
    f64.div
  )
  (export "f32.no_fold_zero_div" (func 2))
  (export "f64.no_fold_zero_div" (func 3))
)
(assert_return (invoke "f32.no_fold_zero_div" (f32.const 0.0)) (f32.const nan:canonical))
(assert_return (invoke "f32.no_fold_zero_div" (f32.const -0.0)) (f32.const nan:canonical))
(assert_return (invoke "f32.no_fold_zero_div" (f32.const nan)) (f32.const nan:canonical))
(assert_return (invoke "f32.no_fold_zero_div" (f32.const nan:0x200000)) (f32.const nan:arithmetic))
(assert_return (invoke "f64.no_fold_zero_div" (f64.const 0.0)) (f64.const nan:canonical))
(assert_return (invoke "f64.no_fold_zero_div" (f64.const -0.0)) (f64.const nan:canonical))
(assert_return (invoke "f64.no_fold_zero_div" (f64.const nan)) (f64.const nan:canonical))
(assert_return (invoke "f64.no_fold_zero_div" (f64.const nan:0x4000000000000)) (f64.const nan:arithmetic))

;; Test that x/1.0 is not folded to x.

(module
  (type (;0;) (func (param f32) (result f32)))
  (type (;1;) (func (param f64) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (result f32)
    i64.const 8
    i64.const 0
    call 1
    i64.const 4
    call 0
    local.get $x
    f32.const 0x1p+0 (;=1;)
    f32.div
  )
  (func (;3;) (type 1) (param $x f64) (result f64)
    i64.const 16
    i64.const 0
    call 1
    i64.const 4
    call 0
    local.get $x
    f64.const 0x1p+0 (;=1;)
    f64.div
  )
  (export "f32.no_fold_div_one" (func 2))
  (export "f64.no_fold_div_one" (func 3))
)
(assert_return (invoke "f32.no_fold_div_one" (f32.const nan:0x200000)) (f32.const nan:arithmetic))
(assert_return (invoke "f64.no_fold_div_one" (f64.const nan:0x4000000000000)) (f64.const nan:arithmetic))

;; Test that x/-1.0 is not folded to -x.

(module
  (type (;0;) (func (param f32) (result f32)))
  (type (;1;) (func (param f64) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (result f32)
    i64.const 8
    i64.const 0
    call 1
    i64.const 4
    call 0
    local.get $x
    f32.const -0x1p+0 (;=-1;)
    f32.div
  )
  (func (;3;) (type 1) (param $x f64) (result f64)
    i64.const 16
    i64.const 0
    call 1
    i64.const 4
    call 0
    local.get $x
    f64.const -0x1p+0 (;=-1;)
    f64.div
  )
  (export "f32.no_fold_div_neg1" (func 2))
  (export "f64.no_fold_div_neg1" (func 3))
)
(assert_return (invoke "f32.no_fold_div_neg1" (f32.const nan:0x200000)) (f32.const nan:arithmetic))
(assert_return (invoke "f64.no_fold_div_neg1" (f64.const nan:0x4000000000000)) (f64.const nan:arithmetic))

;; Test that -0.0 - x is not folded to -x.

(module
  (type (;0;) (func (param f32) (result f32)))
  (type (;1;) (func (param f64) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (result f32)
    i64.const 8
    i64.const 0
    call 1
    i64.const 4
    call 0
    f32.const -0x0p+0 (;=-0;)
    local.get $x
    f32.sub
  )
  (func (;3;) (type 1) (param $x f64) (result f64)
    i64.const 16
    i64.const 0
    call 1
    i64.const 4
    call 0
    f64.const -0x0p+0 (;=-0;)
    local.get $x
    f64.sub
  )
  (export "f32.no_fold_neg0_sub" (func 2))
  (export "f64.no_fold_neg0_sub" (func 3))
)
(assert_return (invoke "f32.no_fold_neg0_sub" (f32.const nan:0x200000)) (f32.const nan:arithmetic))
(assert_return (invoke "f64.no_fold_neg0_sub" (f64.const nan:0x4000000000000)) (f64.const nan:arithmetic))

;; Test that -1.0 * x is not folded to -x.

(module
  (type (;0;) (func (param f32) (result f32)))
  (type (;1;) (func (param f64) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (result f32)
    i64.const 8
    i64.const 0
    call 1
    i64.const 4
    call 0
    f32.const -0x1p+0 (;=-1;)
    local.get $x
    f32.mul
  )
  (func (;3;) (type 1) (param $x f64) (result f64)
    i64.const 16
    i64.const 0
    call 1
    i64.const 4
    call 0
    f64.const -0x1p+0 (;=-1;)
    local.get $x
    f64.mul
  )
  (export "f32.no_fold_neg1_mul" (func 2))
  (export "f64.no_fold_neg1_mul" (func 3))
)
(assert_return (invoke "f32.no_fold_neg1_mul" (f32.const nan:0x200000)) (f32.const nan:arithmetic))
(assert_return (invoke "f64.no_fold_neg1_mul" (f64.const nan:0x4000000000000)) (f64.const nan:arithmetic))

;; Test that x == x is not folded to true.

(module
  (type (;0;) (func (param f32) (result i32)))
  (type (;1;) (func (param f64) (result i32)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (result i32)
    i64.const 8
    i64.const 0
    call 1
    i64.const 4
    call 0
    local.get $x
    local.get $x
    f32.eq
  )
  (func (;3;) (type 1) (param $x f64) (result i32)
    i64.const 16
    i64.const 0
    call 1
    i64.const 4
    call 0
    local.get $x
    local.get $x
    f64.eq
  )
  (export "f32.no_fold_eq_self" (func 2))
  (export "f64.no_fold_eq_self" (func 3))
)
(assert_return (invoke "f32.no_fold_eq_self" (f32.const nan)) (i32.const 0))
(assert_return (invoke "f64.no_fold_eq_self" (f64.const nan)) (i32.const 0))

;; Test that x != x is not folded to false.

(module
  (type (;0;) (func (param f32) (result i32)))
  (type (;1;) (func (param f64) (result i32)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (result i32)
    i64.const 8
    i64.const 0
    call 1
    i64.const 4
    call 0
    local.get $x
    local.get $x
    f32.ne
  )
  (func (;3;) (type 1) (param $x f64) (result i32)
    i64.const 16
    i64.const 0
    call 1
    i64.const 4
    call 0
    local.get $x
    local.get $x
    f64.ne
  )
  (export "f32.no_fold_ne_self" (func 2))
  (export "f64.no_fold_ne_self" (func 3))
)
(assert_return (invoke "f32.no_fold_ne_self" (f32.const nan)) (i32.const 1))
(assert_return (invoke "f64.no_fold_ne_self" (f64.const nan)) (i32.const 1))

;; Test that x - x is not folded to 0.0.

(module
  (type (;0;) (func (param f32) (result f32)))
  (type (;1;) (func (param f64) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (result f32)
    i64.const 8
    i64.const 0
    call 1
    i64.const 4
    call 0
    local.get $x
    local.get $x
    f32.sub
  )
  (func (;3;) (type 1) (param $x f64) (result f64)
    i64.const 16
    i64.const 0
    call 1
    i64.const 4
    call 0
    local.get $x
    local.get $x
    f64.sub
  )
  (export "f32.no_fold_sub_self" (func 2))
  (export "f64.no_fold_sub_self" (func 3))
)
(assert_return (invoke "f32.no_fold_sub_self" (f32.const inf)) (f32.const nan:canonical))
(assert_return (invoke "f32.no_fold_sub_self" (f32.const nan)) (f32.const nan:canonical))
(assert_return (invoke "f64.no_fold_sub_self" (f64.const inf)) (f64.const nan:canonical))
(assert_return (invoke "f64.no_fold_sub_self" (f64.const nan)) (f64.const nan:canonical))

;; Test that x / x is not folded to 1.0.

(module
  (type (;0;) (func (param f32) (result f32)))
  (type (;1;) (func (param f64) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (result f32)
    i64.const 8
    i64.const 0
    call 1
    i64.const 4
    call 0
    local.get $x
    local.get $x
    f32.div
  )
  (func (;3;) (type 1) (param $x f64) (result f64)
    i64.const 16
    i64.const 0
    call 1
    i64.const 4
    call 0
    local.get $x
    local.get $x
    f64.div
  )
  (export "f32.no_fold_div_self" (func 2))
  (export "f64.no_fold_div_self" (func 3))
)
(assert_return (invoke "f32.no_fold_div_self" (f32.const inf)) (f32.const nan:canonical))
(assert_return (invoke "f32.no_fold_div_self" (f32.const nan)) (f32.const nan:canonical))
(assert_return (invoke "f32.no_fold_div_self" (f32.const 0.0)) (f32.const nan:canonical))
(assert_return (invoke "f32.no_fold_div_self" (f32.const -0.0)) (f32.const nan:canonical))
(assert_return (invoke "f64.no_fold_div_self" (f64.const inf)) (f64.const nan:canonical))
(assert_return (invoke "f64.no_fold_div_self" (f64.const nan)) (f64.const nan:canonical))
(assert_return (invoke "f64.no_fold_div_self" (f64.const 0.0)) (f64.const nan:canonical))
(assert_return (invoke "f64.no_fold_div_self" (f64.const -0.0)) (f64.const nan:canonical))

;; Test that x/3 is not folded to x*(1/3).

(module
  (type (;0;) (func (param f32) (result f32)))
  (type (;1;) (func (param f64) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (result f32)
    i64.const 8
    i64.const 0
    call 1
    i64.const 4
    call 0
    local.get $x
    f32.const 0x1.8p+1 (;=3;)
    f32.div
  )
  (func (;3;) (type 1) (param $x f64) (result f64)
    i64.const 16
    i64.const 0
    call 1
    i64.const 4
    call 0
    local.get $x
    f64.const 0x1.8p+1 (;=3;)
    f64.div
  )
  (export "f32.no_fold_div_3" (func 2))
  (export "f64.no_fold_div_3" (func 3))
)
(assert_return (invoke "f32.no_fold_div_3" (f32.const -0x1.359c26p+50)) (f32.const -0x1.9cd032p+48))
(assert_return (invoke "f32.no_fold_div_3" (f32.const -0x1.e45646p+93)) (f32.const -0x1.42e42ep+92))
(assert_return (invoke "f32.no_fold_div_3" (f32.const -0x1.2a3916p-83)) (f32.const -0x1.8da172p-85))
(assert_return (invoke "f32.no_fold_div_3" (f32.const -0x1.1f8b38p-124)) (f32.const -0x1.7f644ap-126))
(assert_return (invoke "f32.no_fold_div_3" (f32.const -0x1.d64f64p-56)) (f32.const -0x1.398a42p-57))
(assert_return (invoke "f64.no_fold_div_3" (f64.const -0x1.a8a88d29e2cc3p+632)) (f64.const -0x1.1b1b08c69732dp+631))
(assert_return (invoke "f64.no_fold_div_3" (f64.const -0x1.bcf52dc950972p-167)) (f64.const -0x1.28a373db8b0f7p-168))
(assert_return (invoke "f64.no_fold_div_3" (f64.const 0x1.bd3c0d989f7a4p-874)) (f64.const 0x1.28d2b3bb14fc3p-875))
(assert_return (invoke "f64.no_fold_div_3" (f64.const -0x1.0138bf530a53cp+1007)) (f64.const -0x1.56f6546eb86fbp+1005))
(assert_return (invoke "f64.no_fold_div_3" (f64.const 0x1.052b87f9d794dp+415)) (f64.const 0x1.5c3a0aa274c67p+413))

;; Test that (x*z)+(y*z) is not folded to (x+y)*z.

(module
  (type (;0;) (func (param f32 f32 f32) (result f32)))
  (type (;1;) (func (param f64 f64 f64) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (param $y f32) (param $z f32) (result f32)
    i64.const 12
    i64.const 2
    call 1
    i64.const 8
    call 0
    local.get $x
    local.get $z
    f32.mul
    local.get $y
    local.get $z
    f32.mul
    f32.add
  )
  (func (;3;) (type 1) (param $x f64) (param $y f64) (param $z f64) (result f64)
    i64.const 24
    i64.const 2
    call 1
    i64.const 8
    call 0
    local.get $x
    local.get $z
    f64.mul
    local.get $y
    local.get $z
    f64.mul
    f64.add
  )
  (export "f32.no_factor" (func 2))
  (export "f64.no_factor" (func 3))
)
(assert_return (invoke "f32.no_factor" (f32.const -0x1.4e2352p+40) (f32.const -0x1.842e2cp+49) (f32.const 0x1.eea602p+59)) (f32.const -0x1.77a7dp+109))
(assert_return (invoke "f32.no_factor" (f32.const -0x1.b4e7f6p-6) (f32.const 0x1.8c990cp-5) (f32.const -0x1.70cc02p-9)) (f32.const -0x1.00a342p-14))
(assert_return (invoke "f32.no_factor" (f32.const -0x1.06722ep-41) (f32.const 0x1.eed3cep-64) (f32.const 0x1.5c5558p+123)) (f32.const -0x1.651aaep+82))
(assert_return (invoke "f32.no_factor" (f32.const -0x1.f8c6a4p-64) (f32.const 0x1.08c806p-83) (f32.const 0x1.b5ceccp+118)) (f32.const -0x1.afa15p+55))
(assert_return (invoke "f32.no_factor" (f32.const -0x1.3aaa1ep-84) (f32.const 0x1.c6d5eep-71) (f32.const 0x1.8d2924p+20)) (f32.const 0x1.60c9cep-50))
(assert_return (invoke "f64.no_factor" (f64.const 0x1.3adeda9144977p-424) (f64.const 0x1.c15af887049e1p-462) (f64.const -0x1.905179c4c4778p-225)) (f64.const -0x1.ec606bcb87b1ap-649))
(assert_return (invoke "f64.no_factor" (f64.const 0x1.3c84821c1d348p-662) (f64.const -0x1.4ffd4c77ad037p-1009) (f64.const -0x1.dd275335c6f4p-957)) (f64.const 0x0p+0))
(assert_return (invoke "f64.no_factor" (f64.const -0x1.074f372347051p-334) (f64.const -0x1.aaeef661f4c96p-282) (f64.const -0x1.9bd34abe8696dp+479)) (f64.const 0x1.5767029593e2p+198))
(assert_return (invoke "f64.no_factor" (f64.const -0x1.c4ded58a6f389p-289) (f64.const 0x1.ba6fdef5d59c9p-260) (f64.const -0x1.c1201c0470205p-253)) (f64.const -0x1.841ada2e0f184p-512))
(assert_return (invoke "f64.no_factor" (f64.const 0x1.9d3688f8e375ap-608) (f64.const 0x1.bf91311588256p-579) (f64.const -0x1.1605a6b5d5ff8p+489)) (f64.const -0x1.e6118ca76af53p-90))

;; Test that (x+y)*z is not folded to (x*z)+(y*z).

(module
  (type (;0;) (func (param f32 f32 f32) (result f32)))
  (type (;1;) (func (param f64 f64 f64) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (param $y f32) (param $z f32) (result f32)
    i64.const 8
    i64.const 2
    call 1
    i64.const 6
    call 0
    local.get $x
    local.get $y
    f32.add
    local.get $z
    f32.mul
  )
  (func (;3;) (type 1) (param $x f64) (param $y f64) (param $z f64) (result f64)
    i64.const 16
    i64.const 2
    call 1
    i64.const 6
    call 0
    local.get $x
    local.get $y
    f64.add
    local.get $z
    f64.mul
  )
  (export "f32.no_distribute" (func 2))
  (export "f64.no_distribute" (func 3))
)
(assert_return (invoke "f32.no_distribute" (f32.const -0x1.4e2352p+40) (f32.const -0x1.842e2cp+49) (f32.const 0x1.eea602p+59)) (f32.const -0x1.77a7d2p+109))
(assert_return (invoke "f32.no_distribute" (f32.const -0x1.b4e7f6p-6) (f32.const 0x1.8c990cp-5) (f32.const -0x1.70cc02p-9)) (f32.const -0x1.00a34p-14))
(assert_return (invoke "f32.no_distribute" (f32.const -0x1.06722ep-41) (f32.const 0x1.eed3cep-64) (f32.const 0x1.5c5558p+123)) (f32.const -0x1.651abp+82))
(assert_return (invoke "f32.no_distribute" (f32.const -0x1.f8c6a4p-64) (f32.const 0x1.08c806p-83) (f32.const 0x1.b5ceccp+118)) (f32.const -0x1.afa14ep+55))
(assert_return (invoke "f32.no_distribute" (f32.const -0x1.3aaa1ep-84) (f32.const 0x1.c6d5eep-71) (f32.const 0x1.8d2924p+20)) (f32.const 0x1.60c9ccp-50))
(assert_return (invoke "f64.no_distribute" (f64.const 0x1.3adeda9144977p-424) (f64.const 0x1.c15af887049e1p-462) (f64.const -0x1.905179c4c4778p-225)) (f64.const -0x1.ec606bcb87b1bp-649))
(assert_return (invoke "f64.no_distribute" (f64.const 0x1.3c84821c1d348p-662) (f64.const -0x1.4ffd4c77ad037p-1009) (f64.const -0x1.dd275335c6f4p-957)) (f64.const -0x0p+0))
(assert_return (invoke "f64.no_distribute" (f64.const -0x1.074f372347051p-334) (f64.const -0x1.aaeef661f4c96p-282) (f64.const -0x1.9bd34abe8696dp+479)) (f64.const 0x1.5767029593e1fp+198))
(assert_return (invoke "f64.no_distribute" (f64.const -0x1.c4ded58a6f389p-289) (f64.const 0x1.ba6fdef5d59c9p-260) (f64.const -0x1.c1201c0470205p-253)) (f64.const -0x1.841ada2e0f183p-512))
(assert_return (invoke "f64.no_distribute" (f64.const 0x1.9d3688f8e375ap-608) (f64.const 0x1.bf91311588256p-579) (f64.const -0x1.1605a6b5d5ff8p+489)) (f64.const -0x1.e6118ca76af52p-90))

;; Test that x*(y/z) is not folded to (x*y)/z.

(module
  (type (;0;) (func (param f32 f32 f32) (result f32)))
  (type (;1;) (func (param f64 f64 f64) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (param $y f32) (param $z f32) (result f32)
    i64.const 12
    i64.const 2
    call 1
    i64.const 6
    call 0
    local.get $x
    local.get $y
    local.get $z
    f32.div
    f32.mul
  )
  (func (;3;) (type 1) (param $x f64) (param $y f64) (param $z f64) (result f64)
    i64.const 24
    i64.const 2
    call 1
    i64.const 6
    call 0
    local.get $x
    local.get $y
    local.get $z
    f64.div
    f64.mul
  )
  (export "f32.no_regroup_div_mul" (func 2))
  (export "f64.no_regroup_div_mul" (func 3))
)
(assert_return (invoke "f32.no_regroup_div_mul" (f32.const -0x1.2d14a6p-115) (f32.const -0x1.575a6cp-64) (f32.const 0x1.5cee0ep-116)) (f32.const 0x1.2844cap-63))
(assert_return (invoke "f32.no_regroup_div_mul" (f32.const -0x1.454738p+91) (f32.const -0x1.b28a66p-115) (f32.const -0x1.f53908p+72)) (f32.const -0x0p+0))
(assert_return (invoke "f32.no_regroup_div_mul" (f32.const -0x1.6be56ep+16) (f32.const -0x1.b46fc6p-21) (f32.const -0x1.a51df6p-123)) (f32.const -0x1.792258p+118))
(assert_return (invoke "f32.no_regroup_div_mul" (f32.const -0x1.c343f8p-94) (f32.const 0x1.e4d906p+73) (f32.const 0x1.be69f8p+68)) (f32.const -0x1.ea1df2p-89))
(assert_return (invoke "f32.no_regroup_div_mul" (f32.const 0x1.c6ae76p+112) (f32.const 0x1.fc953cp+24) (f32.const -0x1.60b3e8p+71)) (f32.const -0x1.47d0eap+66))
(assert_return (invoke "f64.no_regroup_div_mul" (f64.const 0x1.3c04b815e30bp-423) (f64.const -0x1.379646fd98127p-119) (f64.const 0x1.bddb158506031p-642)) (f64.const -0x1.b9b3301f2dd2dp+99))
(assert_return (invoke "f64.no_regroup_div_mul" (f64.const 0x1.46b3a402f86d5p+337) (f64.const 0x1.6fbf1b9e1798dp-447) (f64.const -0x1.bd9704a5a6a06p+797)) (f64.const -0x0p+0))
(assert_return (invoke "f64.no_regroup_div_mul" (f64.const 0x1.6c9765bb4347fp-479) (f64.const 0x1.a4af42e34a141p+902) (f64.const 0x1.d2dde70eb68f9p-448)) (f64.const inf))
(assert_return (invoke "f64.no_regroup_div_mul" (f64.const -0x1.706023645be72p+480) (f64.const -0x1.6c229f7d9101dp+611) (f64.const -0x1.4d50fa68d3d9ep+836)) (f64.const -0x1.926fa3cacc651p+255))
(assert_return (invoke "f64.no_regroup_div_mul" (f64.const 0x1.8cc63d8caf4c7p-599) (f64.const 0x1.8671ac4c35753p-878) (f64.const -0x1.ef35b1695e659p-838)) (f64.const -0x1.38d55f56406dp-639))

;; Test that (x*y)/z is not folded to x*(y/z).

(module
  (type (;0;) (func (param f32 f32 f32) (result f32)))
  (type (;1;) (func (param f64 f64 f64) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (param $y f32) (param $z f32) (result f32)
    i64.const 8
    i64.const 2
    call 1
    i64.const 6
    call 0
    local.get $x
    local.get $y
    f32.mul
    local.get $z
    f32.div
  )
  (func (;3;) (type 1) (param $x f64) (param $y f64) (param $z f64) (result f64)
    i64.const 16
    i64.const 2
    call 1
    i64.const 6
    call 0
    local.get $x
    local.get $y
    f64.mul
    local.get $z
    f64.div
  )
  (export "f32.no_regroup_mul_div" (func 2))
  (export "f64.no_regroup_mul_div" (func 3))
)
(assert_return (invoke "f32.no_regroup_mul_div" (f32.const -0x1.2d14a6p-115) (f32.const -0x1.575a6cp-64) (f32.const 0x1.5cee0ep-116)) (f32.const 0x0p+0))
(assert_return (invoke "f32.no_regroup_mul_div" (f32.const -0x1.454738p+91) (f32.const -0x1.b28a66p-115) (f32.const -0x1.f53908p+72)) (f32.const -0x1.1a00e8p-96))
(assert_return (invoke "f32.no_regroup_mul_div" (f32.const -0x1.6be56ep+16) (f32.const -0x1.b46fc6p-21) (f32.const -0x1.a51df6p-123)) (f32.const -0x1.79225ap+118))
(assert_return (invoke "f32.no_regroup_mul_div" (f32.const -0x1.c343f8p-94) (f32.const 0x1.e4d906p+73) (f32.const 0x1.be69f8p+68)) (f32.const -0x1.ea1df4p-89))
(assert_return (invoke "f32.no_regroup_mul_div" (f32.const 0x1.c6ae76p+112) (f32.const 0x1.fc953cp+24) (f32.const -0x1.60b3e8p+71)) (f32.const -inf))
(assert_return (invoke "f64.no_regroup_mul_div" (f64.const 0x1.3c04b815e30bp-423) (f64.const -0x1.379646fd98127p-119) (f64.const 0x1.bddb158506031p-642)) (f64.const -0x1.b9b3301f2dd2ep+99))
(assert_return (invoke "f64.no_regroup_mul_div" (f64.const 0x1.46b3a402f86d5p+337) (f64.const 0x1.6fbf1b9e1798dp-447) (f64.const -0x1.bd9704a5a6a06p+797)) (f64.const -0x1.0da0b6328e09p-907))
(assert_return (invoke "f64.no_regroup_mul_div" (f64.const 0x1.6c9765bb4347fp-479) (f64.const 0x1.a4af42e34a141p+902) (f64.const 0x1.d2dde70eb68f9p-448)) (f64.const 0x1.4886b6d9a9a79p+871))
(assert_return (invoke "f64.no_regroup_mul_div" (f64.const -0x1.706023645be72p+480) (f64.const -0x1.6c229f7d9101dp+611) (f64.const -0x1.4d50fa68d3d9ep+836)) (f64.const -inf))
(assert_return (invoke "f64.no_regroup_mul_div" (f64.const 0x1.8cc63d8caf4c7p-599) (f64.const 0x1.8671ac4c35753p-878) (f64.const -0x1.ef35b1695e659p-838)) (f64.const -0x0p+0))

;; Test that x+y+z+w is not reassociated.

(module
  (type (;0;) (func (param f32 f32 f32 f32) (result f32)))
  (type (;1;) (func (param f64 f64 f64 f64) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (param $y f32) (param $z f32) (param $w f32) (result f32)
    i64.const 8
    i64.const 3
    call 1
    i64.const 8
    call 0
    local.get $x
    local.get $y
    f32.add
    local.get $z
    f32.add
    local.get $w
    f32.add
  )
  (func (;3;) (type 1) (param $x f64) (param $y f64) (param $z f64) (param $w f64) (result f64)
    i64.const 16
    i64.const 3
    call 1
    i64.const 8
    call 0
    local.get $x
    local.get $y
    f64.add
    local.get $z
    f64.add
    local.get $w
    f64.add
  )
  (export "f32.no_reassociate_add" (func 2))
  (export "f64.no_reassociate_add" (func 3))
)
(assert_return (invoke "f32.no_reassociate_add" (f32.const -0x1.5f7ddcp+44) (f32.const 0x1.854e1p+34) (f32.const -0x1.b2068cp+47) (f32.const -0x1.209692p+41)) (f32.const -0x1.e26c76p+47))
(assert_return (invoke "f32.no_reassociate_add" (f32.const 0x1.da3b78p-9) (f32.const -0x1.4312fap-7) (f32.const 0x1.0395e6p-4) (f32.const -0x1.6d5ea6p-7)) (f32.const 0x1.78b31ap-5))
(assert_return (invoke "f32.no_reassociate_add" (f32.const -0x1.fdb93ap+34) (f32.const -0x1.b6fce6p+41) (f32.const 0x1.c131d8p+44) (f32.const 0x1.8835b6p+38)) (f32.const 0x1.8ff3a2p+44))
(assert_return (invoke "f32.no_reassociate_add" (f32.const 0x1.1739fcp+47) (f32.const 0x1.a4b186p+49) (f32.const -0x1.0c623cp+35) (f32.const 0x1.16a102p+51)) (f32.const 0x1.913ff6p+51))
(assert_return (invoke "f32.no_reassociate_add" (f32.const 0x1.733cfap+108) (f32.const -0x1.38d30cp+108) (f32.const 0x1.2f5854p+105) (f32.const -0x1.ccb058p+94)) (f32.const 0x1.813716p+106))
(assert_return (invoke "f64.no_reassociate_add" (f64.const -0x1.697a4d9ff19a6p+841) (f64.const 0x1.b305466238397p+847) (f64.const 0x1.e0b2d9bfb4e72p+855) (f64.const -0x1.6e1f3ae2b06bbp+857)) (f64.const -0x1.eb0e5936f087ap+856))
(assert_return (invoke "f64.no_reassociate_add" (f64.const 0x1.00ef6746b30e1p-543) (f64.const 0x1.cc1cfafdf3fe1p-544) (f64.const -0x1.f7726df3ecba6p-543) (f64.const -0x1.b26695f99d307p-594)) (f64.const -0x1.074892e3fad76p-547))
(assert_return (invoke "f64.no_reassociate_add" (f64.const -0x1.e807b3bd6d854p+440) (f64.const 0x1.cedae26c2c5fp+407) (f64.const -0x1.00ab6e1442541p+437) (f64.const 0x1.28538a55997bdp+397)) (f64.const -0x1.040e90bf871ebp+441))
(assert_return (invoke "f64.no_reassociate_add" (f64.const -0x1.ba2b6f35a2402p-317) (f64.const 0x1.ad1c3fea7cd9ep-307) (f64.const -0x1.93aace2bf1261p-262) (f64.const 0x1.9fddbe472847ep-260)) (f64.const 0x1.3af30abc2c01bp-260))
(assert_return (invoke "f64.no_reassociate_add" (f64.const -0x1.ccb9c6092fb1dp+641) (f64.const -0x1.4b7c28c108244p+614) (f64.const 0x1.8a7cefef4bde1p+646) (f64.const -0x1.901b28b08b482p+644)) (f64.const 0x1.1810579194126p+646))

;; Test that x*y*z*w is not reassociated.

(module
  (type (;0;) (func (param f32 f32 f32 f32) (result f32)))
  (type (;1;) (func (param f64 f64 f64 f64) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (param $y f32) (param $z f32) (param $w f32) (result f32)
    i64.const 8
    i64.const 3
    call 1
    i64.const 8
    call 0
    local.get $x
    local.get $y
    f32.mul
    local.get $z
    f32.mul
    local.get $w
    f32.mul
  )
  (func (;3;) (type 1) (param $x f64) (param $y f64) (param $z f64) (param $w f64) (result f64)
    i64.const 16
    i64.const 3
    call 1
    i64.const 8
    call 0
    local.get $x
    local.get $y
    f64.mul
    local.get $z
    f64.mul
    local.get $w
    f64.mul
  )
  (export "f32.no_reassociate_mul" (func 2))
  (export "f64.no_reassociate_mul" (func 3))
)
(assert_return (invoke "f32.no_reassociate_mul" (f32.const 0x1.950ba8p-116) (f32.const 0x1.efdacep-33) (f32.const -0x1.5f9bcp+102) (f32.const 0x1.f04508p-56)) (f32.const -0x1.ff356ep-101))
(assert_return (invoke "f32.no_reassociate_mul" (f32.const 0x1.5990aep-56) (f32.const -0x1.7dfb04p+102) (f32.const -0x1.4f774ap-125) (f32.const -0x1.595fe6p+70)) (f32.const -0x1.c7c8fcp-8))
(assert_return (invoke "f32.no_reassociate_mul" (f32.const 0x1.6ad9a4p-48) (f32.const -0x1.9138aap+55) (f32.const -0x1.4a774ep-40) (f32.const 0x1.1ff08p+76)) (f32.const 0x1.9cd8ecp+44))
(assert_return (invoke "f32.no_reassociate_mul" (f32.const 0x1.e1caecp-105) (f32.const 0x1.af0dd2p+77) (f32.const -0x1.016eep+56) (f32.const -0x1.ab70d6p+59)) (f32.const 0x1.54870ep+89))
(assert_return (invoke "f32.no_reassociate_mul" (f32.const -0x1.3b1dcp-99) (f32.const 0x1.4e5a34p-49) (f32.const -0x1.38ba5ap+3) (f32.const 0x1.7fb8eep+59)) (f32.const 0x1.5bbf98p-85))
(assert_return (invoke "f64.no_reassociate_mul" (f64.const -0x1.e7842ab7181p-667) (f64.const -0x1.fabf40ceeceafp+990) (f64.const -0x1.1a38a825ab01ap-376) (f64.const -0x1.27e8ea469b14fp+664)) (f64.const 0x1.336eb428af4f3p+613))
(assert_return (invoke "f64.no_reassociate_mul" (f64.const 0x1.4ca2292a6acbcp+454) (f64.const 0x1.6ffbab850089ap-516) (f64.const -0x1.547c32e1f5b93p-899) (f64.const -0x1.c7571d9388375p+540)) (f64.const 0x1.1ac796954fc1p-419))
(assert_return (invoke "f64.no_reassociate_mul" (f64.const 0x1.73881a52e0401p-501) (f64.const -0x1.1b68dd9efb1a7p+788) (f64.const 0x1.d1c5e6a3eb27cp-762) (f64.const -0x1.56cb2fcc7546fp+88)) (f64.const 0x1.f508db92c34efp-386))
(assert_return (invoke "f64.no_reassociate_mul" (f64.const 0x1.2efa87859987cp+692) (f64.const 0x1.68e4373e241p-423) (f64.const 0x1.4e2d0fb383a57p+223) (f64.const -0x1.301d3265c737bp-23)) (f64.const -0x1.4b2b6c393f30cp+470))
(assert_return (invoke "f64.no_reassociate_mul" (f64.const 0x1.1013f7498b95fp-234) (f64.const 0x1.d2d1c36fff138p-792) (f64.const -0x1.cbf1824ea7bfdp+728) (f64.const -0x1.440da9c8b836dp-599)) (f64.const 0x1.1a16512881c91p-895))

;; Test that x/0 is not folded away.

(module
  (type (;0;) (func (param f32) (result f32)))
  (type (;1;) (func (param f64) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (result f32)
    i64.const 8
    i64.const 0
    call 1
    i64.const 4
    call 0
    local.get $x
    f32.const 0x0p+0 (;=0;)
    f32.div
  )
  (func (;3;) (type 1) (param $x f64) (result f64)
    i64.const 16
    i64.const 0
    call 1
    i64.const 4
    call 0
    local.get $x
    f64.const 0x0p+0 (;=0;)
    f64.div
  )
  (export "f32.no_fold_div_0" (func 2))
  (export "f64.no_fold_div_0" (func 3))
)
(assert_return (invoke "f32.no_fold_div_0" (f32.const 1.0)) (f32.const inf))
(assert_return (invoke "f32.no_fold_div_0" (f32.const -1.0)) (f32.const -inf))
(assert_return (invoke "f32.no_fold_div_0" (f32.const inf)) (f32.const inf))
(assert_return (invoke "f32.no_fold_div_0" (f32.const -inf)) (f32.const -inf))
(assert_return (invoke "f32.no_fold_div_0" (f32.const 0)) (f32.const nan:canonical))
(assert_return (invoke "f32.no_fold_div_0" (f32.const -0)) (f32.const nan:canonical))
(assert_return (invoke "f32.no_fold_div_0" (f32.const nan:0x200000)) (f32.const nan:arithmetic))
(assert_return (invoke "f32.no_fold_div_0" (f32.const nan)) (f32.const nan:canonical))
(assert_return (invoke "f64.no_fold_div_0" (f64.const 1.0)) (f64.const inf))
(assert_return (invoke "f64.no_fold_div_0" (f64.const -1.0)) (f64.const -inf))
(assert_return (invoke "f64.no_fold_div_0" (f64.const inf)) (f64.const inf))
(assert_return (invoke "f64.no_fold_div_0" (f64.const -inf)) (f64.const -inf))
(assert_return (invoke "f64.no_fold_div_0" (f64.const 0)) (f64.const nan:canonical))
(assert_return (invoke "f64.no_fold_div_0" (f64.const -0)) (f64.const nan:canonical))
(assert_return (invoke "f64.no_fold_div_0" (f64.const nan)) (f64.const nan:canonical))
(assert_return (invoke "f64.no_fold_div_0" (f64.const nan:0x4000000000000)) (f64.const nan:arithmetic))

;; Test that x/-0 is not folded away.

(module
  (type (;0;) (func (param f32) (result f32)))
  (type (;1;) (func (param f64) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (result f32)
    i64.const 8
    i64.const 0
    call 1
    i64.const 4
    call 0
    local.get $x
    f32.const -0x0p+0 (;=-0;)
    f32.div
  )
  (func (;3;) (type 1) (param $x f64) (result f64)
    i64.const 16
    i64.const 0
    call 1
    i64.const 4
    call 0
    local.get $x
    f64.const -0x0p+0 (;=-0;)
    f64.div
  )
  (export "f32.no_fold_div_neg0" (func 2))
  (export "f64.no_fold_div_neg0" (func 3))
)
(assert_return (invoke "f32.no_fold_div_neg0" (f32.const 1.0)) (f32.const -inf))
(assert_return (invoke "f32.no_fold_div_neg0" (f32.const -1.0)) (f32.const inf))
(assert_return (invoke "f32.no_fold_div_neg0" (f32.const inf)) (f32.const -inf))
(assert_return (invoke "f32.no_fold_div_neg0" (f32.const -inf)) (f32.const inf))
(assert_return (invoke "f32.no_fold_div_neg0" (f32.const 0)) (f32.const nan:canonical))
(assert_return (invoke "f32.no_fold_div_neg0" (f32.const -0)) (f32.const nan:canonical))
(assert_return (invoke "f32.no_fold_div_neg0" (f32.const nan:0x200000)) (f32.const nan:arithmetic))
(assert_return (invoke "f32.no_fold_div_neg0" (f32.const nan)) (f32.const nan:canonical))
(assert_return (invoke "f64.no_fold_div_neg0" (f64.const 1.0)) (f64.const -inf))
(assert_return (invoke "f64.no_fold_div_neg0" (f64.const -1.0)) (f64.const inf))
(assert_return (invoke "f64.no_fold_div_neg0" (f64.const inf)) (f64.const -inf))
(assert_return (invoke "f64.no_fold_div_neg0" (f64.const -inf)) (f64.const inf))
(assert_return (invoke "f64.no_fold_div_neg0" (f64.const 0)) (f64.const nan:canonical))
(assert_return (invoke "f64.no_fold_div_neg0" (f64.const -0)) (f64.const nan:canonical))
(assert_return (invoke "f64.no_fold_div_neg0" (f64.const nan)) (f64.const nan:canonical))
(assert_return (invoke "f64.no_fold_div_neg0" (f64.const nan:0x4000000000000)) (f64.const nan:arithmetic))

;; Test that sqrt(x*x+y*y) is not folded to hypot.

(module
  (type (;0;) (func (param f32 f32) (result f32)))
  (type (;1;) (func (param f64 f64) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (param $y f32) (result f32)
    i64.const 12
    i64.const 1
    call 1
    i64.const 9
    call 0
    local.get $x
    local.get $x
    f32.mul
    local.get $y
    local.get $y
    f32.mul
    f32.add
    f32.sqrt
  )
  (func (;3;) (type 1) (param $x f64) (param $y f64) (result f64)
    i64.const 24
    i64.const 1
    call 1
    i64.const 9
    call 0
    local.get $x
    local.get $x
    f64.mul
    local.get $y
    local.get $y
    f64.mul
    f64.add
    f64.sqrt
  )
  (export "f32.no_fold_to_hypot" (func 2))
  (export "f64.no_fold_to_hypot" (func 3))
)
(assert_return (invoke "f32.no_fold_to_hypot" (f32.const 0x1.c2f338p-81) (f32.const 0x1.401b5ep-68)) (f32.const 0x1.401cccp-68))
(assert_return (invoke "f32.no_fold_to_hypot" (f32.const -0x1.c38d1p-71) (f32.const -0x1.359ddp-107)) (f32.const 0x1.c36a62p-71))
(assert_return (invoke "f32.no_fold_to_hypot" (f32.const -0x1.99e0cap-114) (f32.const -0x1.ed0c6cp-69)) (f32.const 0x1.ed0e48p-69))
(assert_return (invoke "f32.no_fold_to_hypot" (f32.const -0x1.1b6ceap+5) (f32.const 0x1.5440bep+17)) (f32.const 0x1.5440cp+17))
(assert_return (invoke "f32.no_fold_to_hypot" (f32.const 0x1.8f019ep-76) (f32.const -0x1.182308p-71)) (f32.const 0x1.17e2bcp-71))
(assert_return (invoke "f64.no_fold_to_hypot" (f64.const 0x1.1a0ac4f7c8711p-636) (f64.const 0x1.1372ebafff551p-534)) (f64.const 0x1.13463fa37014ep-534))
(assert_return (invoke "f64.no_fold_to_hypot" (f64.const 0x1.b793512167499p+395) (f64.const -0x1.11cbc52af4c36p+410)) (f64.const 0x1.11cbc530783a2p+410))
(assert_return (invoke "f64.no_fold_to_hypot" (f64.const 0x1.76777f44ff40bp-536) (f64.const -0x1.c3896e4dc1fbp-766)) (f64.const 0x1.8p-536))
(assert_return (invoke "f64.no_fold_to_hypot" (f64.const -0x1.889ac72cc6b5dp-521) (f64.const 0x1.8d7084e659f3bp-733)) (f64.const 0x1.889ac72ca843ap-521))
(assert_return (invoke "f64.no_fold_to_hypot" (f64.const 0x1.5ee588c02cb08p-670) (f64.const -0x1.05ce25788d9ecp-514)) (f64.const 0x1.05ce25788d9dfp-514))

;; Test that 1.0/x isn't approximated.

(module
  (type (;0;) (func (param f32) (result f32)))
  (type (;1;) (func (param i64)))
  (type (;2;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 1)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 2)))
  (func (;2;) (type 0) (param $x f32) (result f32)
    i64.const 8
    i64.const 0
    call 1
    i64.const 4
    call 0
    f32.const 0x1p+0 (;=1;)
    local.get $x
    f32.div
  )
  (export "f32.no_approximate_reciprocal" (func 2))
)
(assert_return (invoke "f32.no_approximate_reciprocal" (f32.const -0x1.2900b6p-10)) (f32.const -0x1.b950d4p+9))
(assert_return (invoke "f32.no_approximate_reciprocal" (f32.const 0x1.e7212p+127)) (f32.const 0x1.0d11f8p-128))
(assert_return (invoke "f32.no_approximate_reciprocal" (f32.const -0x1.42a466p-93)) (f32.const -0x1.963ee6p+92))
(assert_return (invoke "f32.no_approximate_reciprocal" (f32.const 0x1.5d0c32p+76)) (f32.const 0x1.778362p-77))
(assert_return (invoke "f32.no_approximate_reciprocal" (f32.const -0x1.601de2p-82)) (f32.const -0x1.743d7ep+81))

;; Test that 1.0/sqrt(x) isn't approximated or fused.

(module
  (type (;0;) (func (param f32) (result f32)))
  (type (;1;) (func (param f64) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (result f32)
    i64.const 8
    i64.const 0
    call 1
    i64.const 5
    call 0
    f32.const 0x1p+0 (;=1;)
    local.get $x
    f32.sqrt
    f32.div
  )
  (func (;3;) (type 1) (param $x f64) (result f64)
    i64.const 16
    i64.const 0
    call 1
    i64.const 5
    call 0
    f64.const 0x1p+0 (;=1;)
    local.get $x
    f64.sqrt
    f64.div
  )
  (export "f32.no_approximate_reciprocal_sqrt" (func 2))
  (export "f64.no_fuse_reciprocal_sqrt" (func 3))
)
(assert_return (invoke "f32.no_approximate_reciprocal_sqrt" (f32.const 0x1.6af12ap-43)) (f32.const 0x1.300ed4p+21))
(assert_return (invoke "f32.no_approximate_reciprocal_sqrt" (f32.const 0x1.e82fc6p-8)) (f32.const 0x1.72c376p+3))
(assert_return (invoke "f32.no_approximate_reciprocal_sqrt" (f32.const 0x1.b9fa9cp-66)) (f32.const 0x1.85a9bap+32))
(assert_return (invoke "f32.no_approximate_reciprocal_sqrt" (f32.const 0x1.f4f546p-44)) (f32.const 0x1.6e01c2p+21))
(assert_return (invoke "f32.no_approximate_reciprocal_sqrt" (f32.const 0x1.5da7aap-86)) (f32.const 0x1.b618cap+42))

(assert_return (invoke "f64.no_fuse_reciprocal_sqrt" (f64.const 0x1.1568a63b55fa3p+889)) (f64.const 0x1.5bc9c74c9952p-445))
(assert_return (invoke "f64.no_fuse_reciprocal_sqrt" (f64.const 0x1.239fcd0939cafp+311)) (f64.const 0x1.5334a922b4818p-156))
(assert_return (invoke "f64.no_fuse_reciprocal_sqrt" (f64.const 0x1.6e36a24e11054p+104)) (f64.const 0x1.ac13f20977f29p-53))
(assert_return (invoke "f64.no_fuse_reciprocal_sqrt" (f64.const 0x1.23ee173219f83p+668)) (f64.const 0x1.df753e055862dp-335))
(assert_return (invoke "f64.no_fuse_reciprocal_sqrt" (f64.const 0x1.b30f74caf9babp+146)) (f64.const 0x1.88bfc3d1764a9p-74))

;; Test that sqrt(1.0/x) isn't approximated.

(module
  (type (;0;) (func (param f32) (result f32)))
  (type (;1;) (func (param i64)))
  (type (;2;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 1)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 2)))
  (func (;2;) (type 0) (param $x f32) (result f32)
    i64.const 8
    i64.const 0
    call 1
    i64.const 5
    call 0
    f32.const 0x1p+0 (;=1;)
    local.get $x
    f32.div
    f32.sqrt
  )
  (export "f32.no_approximate_sqrt_reciprocal" (func 2))
)
(assert_return (invoke "f32.no_approximate_sqrt_reciprocal" (f32.const 0x1.a4c986p+60)) (f32.const 0x1.8f5ac6p-31))
(assert_return (invoke "f32.no_approximate_sqrt_reciprocal" (f32.const 0x1.50511ep-9)) (f32.const 0x1.3bdd46p+4))
(assert_return (invoke "f32.no_approximate_sqrt_reciprocal" (f32.const 0x1.125ec2p+69)) (f32.const 0x1.5db572p-35))
(assert_return (invoke "f32.no_approximate_sqrt_reciprocal" (f32.const 0x1.ba4c5p+13)) (f32.const 0x1.136f16p-7))
(assert_return (invoke "f32.no_approximate_sqrt_reciprocal" (f32.const 0x1.4a5be2p+104)) (f32.const 0x1.c2b5bp-53))

;; Test that converting i32/i64 to f32/f64 and back isn't folded away.

(module
  (type (;0;) (func (param i32) (result i32)))
  (type (;1;) (func (param i64) (result i64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param i32) (result i32)
    i64.const 4
    i64.const 0
    call 1
    i64.const 3
    call 0
    local.get 0
    f32.convert_i32_s
    i32.trunc_f32_s
    i64.const 1
    call 0
  )
  (func (;3;) (type 0) (param i32) (result i32)
    i64.const 4
    i64.const 0
    call 1
    i64.const 3
    call 0
    local.get 0
    f32.convert_i32_u
    i32.trunc_f32_u
    i64.const 1
    call 0
  )
  (func (;4;) (type 1) (param i64) (result i64)
    i64.const 8
    i64.const 0
    call 1
    i64.const 3
    call 0
    local.get 0
    f64.convert_i64_s
    i64.trunc_f64_s
    i64.const 1
    call 0
  )
  (func (;5;) (type 1) (param i64) (result i64)
    i64.const 8
    i64.const 0
    call 1
    i64.const 3
    call 0
    local.get 0
    f64.convert_i64_u
    i64.trunc_f64_u
    i64.const 1
    call 0
  )
  (export "i32.no_fold_f32_s" (func 2))
  (export "i32.no_fold_f32_u" (func 3))
  (export "i64.no_fold_f64_s" (func 4))
  (export "i64.no_fold_f64_u" (func 5))
)
(assert_return (invoke "i32.no_fold_f32_s" (i32.const 0x1000000)) (i32.const 0x1000000))
(assert_return (invoke "i32.no_fold_f32_s" (i32.const 0x1000001)) (i32.const 0x1000000))
(assert_return (invoke "i32.no_fold_f32_s" (i32.const 0xf0000010)) (i32.const 0xf0000010))

(assert_return (invoke "i32.no_fold_f32_u" (i32.const 0x1000000)) (i32.const 0x1000000))
(assert_return (invoke "i32.no_fold_f32_u" (i32.const 0x1000001)) (i32.const 0x1000000))
(assert_return (invoke "i32.no_fold_f32_u" (i32.const 0xf0000010)) (i32.const 0xf0000000))

(assert_return (invoke "i64.no_fold_f64_s" (i64.const 0x20000000000000)) (i64.const 0x20000000000000))
(assert_return (invoke "i64.no_fold_f64_s" (i64.const 0x20000000000001)) (i64.const 0x20000000000000))
(assert_return (invoke "i64.no_fold_f64_s" (i64.const 0xf000000000000400)) (i64.const 0xf000000000000400))

(assert_return (invoke "i64.no_fold_f64_u" (i64.const 0x20000000000000)) (i64.const 0x20000000000000))
(assert_return (invoke "i64.no_fold_f64_u" (i64.const 0x20000000000001)) (i64.const 0x20000000000000))
(assert_return (invoke "i64.no_fold_f64_u" (i64.const 0xf000000000000400)) (i64.const 0xf000000000000000))

;; Test that x+y-y is not folded to x.

(module
  (type (;0;) (func (param f32 f32) (result f32)))
  (type (;1;) (func (param f64 f64) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (param $y f32) (result f32)
    i64.const 8
    i64.const 1
    call 1
    i64.const 6
    call 0
    local.get $x
    local.get $y
    f32.add
    local.get $y
    f32.sub
  )
  (func (;3;) (type 1) (param $x f64) (param $y f64) (result f64)
    i64.const 16
    i64.const 1
    call 1
    i64.const 6
    call 0
    local.get $x
    local.get $y
    f64.add
    local.get $y
    f64.sub
  )
  (export "f32.no_fold_add_sub" (func 2))
  (export "f64.no_fold_add_sub" (func 3))
)
(assert_return (invoke "f32.no_fold_add_sub" (f32.const 0x1.b553e4p-47) (f32.const -0x1.67db2cp-26)) (f32.const 0x1.cp-47))
(assert_return (invoke "f32.no_fold_add_sub" (f32.const -0x1.a884dp-23) (f32.const 0x1.f2ae1ep-19)) (f32.const -0x1.a884ep-23))
(assert_return (invoke "f32.no_fold_add_sub" (f32.const -0x1.fc04fp+82) (f32.const -0x1.65403ap+101)) (f32.const -0x1p+83))
(assert_return (invoke "f32.no_fold_add_sub" (f32.const 0x1.870fa2p-78) (f32.const 0x1.c54916p-56)) (f32.const 0x1.8p-78))
(assert_return (invoke "f32.no_fold_add_sub" (f32.const -0x1.17e966p-108) (f32.const -0x1.5fa61ap-84)) (f32.const -0x1p-107))

(assert_return (invoke "f64.no_fold_add_sub" (f64.const -0x1.1053ea172dba8p-874) (f64.const 0x1.113c413408ac8p-857)) (f64.const -0x1.1053ea172p-874))
(assert_return (invoke "f64.no_fold_add_sub" (f64.const 0x1.e377d54807972p-546) (f64.const 0x1.040a0a4d1ff7p-526)) (f64.const 0x1.e377d548p-546))
(assert_return (invoke "f64.no_fold_add_sub" (f64.const -0x1.75f53cd926b62p-30) (f64.const -0x1.66b176e602bb5p-3)) (f64.const -0x1.75f53dp-30))
(assert_return (invoke "f64.no_fold_add_sub" (f64.const -0x1.c450ff28332ap-341) (f64.const 0x1.15a5855023baep-305)) (f64.const -0x1.c451p-341))
(assert_return (invoke "f64.no_fold_add_sub" (f64.const -0x1.1ad4a596d3ea8p-619) (f64.const -0x1.17d81a41c0ea8p-588)) (f64.const -0x1.1ad4a8p-619))

;; Test that x-y+y is not folded to x.

(module
  (type (;0;) (func (param f32 f32) (result f32)))
  (type (;1;) (func (param f64 f64) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (param $y f32) (result f32)
    i64.const 8
    i64.const 1
    call 1
    i64.const 6
    call 0
    local.get $x
    local.get $y
    f32.sub
    local.get $y
    f32.add
  )
  (func (;3;) (type 1) (param $x f64) (param $y f64) (result f64)
    i64.const 16
    i64.const 1
    call 1
    i64.const 6
    call 0
    local.get $x
    local.get $y
    f64.sub
    local.get $y
    f64.add
  )
  (export "f32.no_fold_sub_add" (func 2))
  (export "f64.no_fold_sub_add" (func 3))
)
(assert_return (invoke "f32.no_fold_sub_add" (f32.const -0x1.523cb8p+9) (f32.const 0x1.93096cp+8)) (f32.const -0x1.523cbap+9))
(assert_return (invoke "f32.no_fold_sub_add" (f32.const -0x1.a31a1p-111) (f32.const 0x1.745efp-95)) (f32.const -0x1.a4p-111))
(assert_return (invoke "f32.no_fold_sub_add" (f32.const 0x1.3d5328p+26) (f32.const 0x1.58567p+35)) (f32.const 0x1.3d54p+26))
(assert_return (invoke "f32.no_fold_sub_add" (f32.const 0x1.374e26p-39) (f32.const -0x1.66a5p-27)) (f32.const 0x1.374p-39))
(assert_return (invoke "f32.no_fold_sub_add" (f32.const 0x1.320facp-3) (f32.const -0x1.ac069ap+14)) (f32.const 0x1.34p-3))

(assert_return (invoke "f64.no_fold_sub_add" (f64.const 0x1.8f92aad2c9b8dp+255) (f64.const -0x1.08cd4992266cbp+259)) (f64.const 0x1.8f92aad2c9b9p+255))
(assert_return (invoke "f64.no_fold_sub_add" (f64.const 0x1.5aaff55742c8bp-666) (f64.const 0x1.8f5f47181f46dp-647)) (f64.const 0x1.5aaff5578p-666))
(assert_return (invoke "f64.no_fold_sub_add" (f64.const 0x1.21bc52967a98dp+251) (f64.const -0x1.fcffaa32d0884p+300)) (f64.const 0x1.2p+251))
(assert_return (invoke "f64.no_fold_sub_add" (f64.const 0x1.9c78361f47374p-26) (f64.const -0x1.69d69f4edc61cp-13)) (f64.const 0x1.9c78361f48p-26))
(assert_return (invoke "f64.no_fold_sub_add" (f64.const 0x1.4dbe68e4afab2p-367) (f64.const -0x1.dc24e5b39cd02p-361)) (f64.const 0x1.4dbe68e4afacp-367))

;; Test that x*y/y is not folded to x.

(module
  (type (;0;) (func (param f32 f32) (result f32)))
  (type (;1;) (func (param f64 f64) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (param $y f32) (result f32)
    i64.const 8
    i64.const 1
    call 1
    i64.const 6
    call 0
    local.get $x
    local.get $y
    f32.mul
    local.get $y
    f32.div
  )
  (func (;3;) (type 1) (param $x f64) (param $y f64) (result f64)
    i64.const 16
    i64.const 1
    call 1
    i64.const 6
    call 0
    local.get $x
    local.get $y
    f64.mul
    local.get $y
    f64.div
  )
  (export "f32.no_fold_mul_div" (func 2))
  (export "f64.no_fold_mul_div" (func 3))
)
(assert_return (invoke "f32.no_fold_mul_div" (f32.const -0x1.cd859ap+54) (f32.const 0x1.6ca936p-47)) (f32.const -0x1.cd8598p+54))
(assert_return (invoke "f32.no_fold_mul_div" (f32.const -0x1.0b56b8p-26) (f32.const 0x1.48264cp-106)) (f32.const -0x1.0b56a4p-26))
(assert_return (invoke "f32.no_fold_mul_div" (f32.const -0x1.e7555cp-48) (f32.const -0x1.9161cp+48)) (f32.const -0x1.e7555ap-48))
(assert_return (invoke "f32.no_fold_mul_div" (f32.const 0x1.aaa50ep+52) (f32.const -0x1.dfb39ep+60)) (f32.const 0x1.aaa50cp+52))
(assert_return (invoke "f32.no_fold_mul_div" (f32.const -0x1.2b7dfap-92) (f32.const -0x1.7c4ca6p-37)) (f32.const -0x1.2b7dfep-92))

(assert_return (invoke "f64.no_fold_mul_div" (f64.const -0x1.3d79ff4118a1ap-837) (f64.const -0x1.b8b5dda31808cp-205)) (f64.const -0x1.3d79ff412263ep-837))
(assert_return (invoke "f64.no_fold_mul_div" (f64.const 0x1.f894d1ee6b3a4p+384) (f64.const 0x1.8c2606d03d58ap+585)) (f64.const 0x1.f894d1ee6b3a5p+384))
(assert_return (invoke "f64.no_fold_mul_div" (f64.const -0x1.a022260acc993p+238) (f64.const -0x1.5fbc128fc8e3cp-552)) (f64.const -0x1.a022260acc992p+238))
(assert_return (invoke "f64.no_fold_mul_div" (f64.const 0x1.9d4b8ed174f54p-166) (f64.const 0x1.ee3d467aeeac6p-906)) (f64.const 0x1.8dcc95a053b2bp-166))
(assert_return (invoke "f64.no_fold_mul_div" (f64.const -0x1.e95ea897cdcd4p+660) (f64.const -0x1.854d5df085f2ep-327)) (f64.const -0x1.e95ea897cdcd5p+660))

;; Test that x/y*y is not folded to x.

(module
  (type (;0;) (func (param f32 f32) (result f32)))
  (type (;1;) (func (param f64 f64) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (param $y f32) (result f32)
    i64.const 8
    i64.const 1
    call 1
    i64.const 6
    call 0
    local.get $x
    local.get $y
    f32.div
    local.get $y
    f32.mul
  )
  (func (;3;) (type 1) (param $x f64) (param $y f64) (result f64)
    i64.const 16
    i64.const 1
    call 1
    i64.const 6
    call 0
    local.get $x
    local.get $y
    f64.div
    local.get $y
    f64.mul
  )
  (export "f32.no_fold_div_mul" (func 2))
  (export "f64.no_fold_div_mul" (func 3))
)
(assert_return (invoke "f32.no_fold_div_mul" (f32.const -0x1.dc6364p+38) (f32.const 0x1.d630ecp+29)) (f32.const -0x1.dc6362p+38))
(assert_return (invoke "f32.no_fold_div_mul" (f32.const -0x1.1f9836p-52) (f32.const -0x1.16c4e4p-18)) (f32.const -0x1.1f9838p-52))
(assert_return (invoke "f32.no_fold_div_mul" (f32.const 0x1.c5972cp-126) (f32.const -0x1.d6659ep+7)) (f32.const 0x1.c5980ep-126))
(assert_return (invoke "f32.no_fold_div_mul" (f32.const -0x1.2e3a9ep-74) (f32.const -0x1.353994p+59)) (f32.const -0x1.2e3a4p-74))
(assert_return (invoke "f32.no_fold_div_mul" (f32.const 0x1.d96b82p-98) (f32.const 0x1.95d908p+27)) (f32.const 0x1.d96b84p-98))

(assert_return (invoke "f64.no_fold_div_mul" (f64.const 0x1.d01f913a52481p-876) (f64.const -0x1.2cd0668b28344p+184)) (f64.const 0x1.d020daf71cdcp-876))
(assert_return (invoke "f64.no_fold_div_mul" (f64.const -0x1.81cb7d400918dp-714) (f64.const 0x1.7caa643586d6ep-53)) (f64.const -0x1.81cb7d400918ep-714))
(assert_return (invoke "f64.no_fold_div_mul" (f64.const -0x1.66904c97b5c8ep-145) (f64.const 0x1.5c3481592ad4cp+428)) (f64.const -0x1.66904c97b5c8dp-145))
(assert_return (invoke "f64.no_fold_div_mul" (f64.const -0x1.e75859d2f0765p-278) (f64.const -0x1.5f19b6ab497f9p+283)) (f64.const -0x1.e75859d2f0764p-278))
(assert_return (invoke "f64.no_fold_div_mul" (f64.const -0x1.515fe9c3b5f5p+620) (f64.const 0x1.36be869c99f7ap+989)) (f64.const -0x1.515fe9c3b5f4fp+620))

;; Test that x/2*2 is not folded to x.

(module
  (type (;0;) (func (param f32) (result f32)))
  (type (;1;) (func (param f64) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (result f32)
    i64.const 8
    i64.const 0
    call 1
    i64.const 6
    call 0
    local.get $x
    f32.const 0x1p+1 (;=2;)
    f32.div
    f32.const 0x1p+1 (;=2;)
    f32.mul
  )
  (func (;3;) (type 1) (param $x f64) (result f64)
    i64.const 16
    i64.const 0
    call 1
    i64.const 6
    call 0
    local.get $x
    f64.const 0x1p+1 (;=2;)
    f64.div
    f64.const 0x1p+1 (;=2;)
    f64.mul
  )
  (export "f32.no_fold_div2_mul2" (func 2))
  (export "f64.no_fold_div2_mul2" (func 3))
)
(assert_return (invoke "f32.no_fold_div2_mul2" (f32.const 0x1.fffffep-126)) (f32.const 0x1p-125))
(assert_return (invoke "f64.no_fold_div2_mul2" (f64.const 0x1.fffffffffffffp-1022)) (f64.const 0x1p-1021))

;; Test that promote(demote(x)) is not folded to x.

(module
  (type (;0;) (func (param f64) (result f64)))
  (type (;1;) (func (param i64)))
  (type (;2;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 1)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 2)))
  (func (;2;) (type 0) (param $x f64) (result f64)
    i64.const 8
    i64.const 0
    call 1
    i64.const 4
    call 0
    local.get $x
    f32.demote_f64
    f64.promote_f32
  )
  (export "no_fold_demote_promote" (func 2))
)
(assert_return (invoke "no_fold_demote_promote" (f64.const -0x1.dece272390f5dp-133)) (f64.const -0x1.decep-133))
(assert_return (invoke "no_fold_demote_promote" (f64.const -0x1.19e6c79938a6fp-85)) (f64.const -0x1.19e6c8p-85))
(assert_return (invoke "no_fold_demote_promote" (f64.const 0x1.49b297ec44dc1p+107)) (f64.const 0x1.49b298p+107))
(assert_return (invoke "no_fold_demote_promote" (f64.const -0x1.74f5bd865163p-88)) (f64.const -0x1.74f5bep-88))
(assert_return (invoke "no_fold_demote_promote" (f64.const 0x1.26d675662367ep+104)) (f64.const 0x1.26d676p+104))

;; Test that demote(promote(x)) is not folded to x, and aside from NaN is
;; bit-preserving.

(module
  (type (;0;) (func (param f32) (result f32)))
  (type (;1;) (func (param i64)))
  (type (;2;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 1)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 2)))
  (func (;2;) (type 0) (param $x f32) (result f32)
    i64.const 8
    i64.const 0
    call 1
    i64.const 4
    call 0
    local.get $x
    f64.promote_f32
    f32.demote_f64
  )
  (export "no_fold_promote_demote" (func 2))
)
(assert_return (invoke "no_fold_promote_demote" (f32.const nan:0x200000)) (f32.const nan:arithmetic))
(assert_return (invoke "no_fold_promote_demote" (f32.const 0x0p+0)) (f32.const 0x0p+0))
(assert_return (invoke "no_fold_promote_demote" (f32.const -0x0p+0)) (f32.const -0x0p+0))
(assert_return (invoke "no_fold_promote_demote" (f32.const 0x1p-149)) (f32.const 0x1p-149))
(assert_return (invoke "no_fold_promote_demote" (f32.const -0x1p-149)) (f32.const -0x1p-149))
(assert_return (invoke "no_fold_promote_demote" (f32.const 0x1.fffffcp-127)) (f32.const 0x1.fffffcp-127))
(assert_return (invoke "no_fold_promote_demote" (f32.const -0x1.fffffcp-127)) (f32.const -0x1.fffffcp-127))
(assert_return (invoke "no_fold_promote_demote" (f32.const 0x1p-126)) (f32.const 0x1p-126))
(assert_return (invoke "no_fold_promote_demote" (f32.const -0x1p-126)) (f32.const -0x1p-126))
(assert_return (invoke "no_fold_promote_demote" (f32.const 0x1.fffffep+127)) (f32.const 0x1.fffffep+127))
(assert_return (invoke "no_fold_promote_demote" (f32.const -0x1.fffffep+127)) (f32.const -0x1.fffffep+127))
(assert_return (invoke "no_fold_promote_demote" (f32.const inf)) (f32.const inf))
(assert_return (invoke "no_fold_promote_demote" (f32.const -inf)) (f32.const -inf))

;; Test that demote(x+promote(y)) is not folded to demote(x)+y.

(module
  (type (;0;) (func (param f64 f32) (result f32)))
  (type (;1;) (func (param f32 f64) (result f32)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f64) (param $y f32) (result f32)
    i64.const 16
    i64.const 1
    call 1
    i64.const 6
    call 0
    local.get $x
    local.get $y
    f64.promote_f32
    f64.add
    f32.demote_f64
  )
  (func (;3;) (type 1) (param $y f32) (param $x f64) (result f32)
    i64.const 16
    i64.const 1
    call 1
    i64.const 6
    call 0
    local.get $y
    f64.promote_f32
    local.get $x
    f64.add
    f32.demote_f64
  )
  (export "no_demote_mixed_add" (func 2))
  (export "no_demote_mixed_add_commuted" (func 3))
)
(assert_return (invoke "no_demote_mixed_add" (f64.const 0x1.f51a9d04854f9p-95) (f32.const 0x1.3f4e9cp-119)) (f32.const 0x1.f51a9ep-95))
(assert_return (invoke "no_demote_mixed_add" (f64.const 0x1.065b3d81ad8dp+37) (f32.const 0x1.758cd8p+38)) (f32.const 0x1.f8ba76p+38))
(assert_return (invoke "no_demote_mixed_add" (f64.const 0x1.626c80963bd17p-119) (f32.const -0x1.9bbf86p-121)) (f32.const 0x1.f6f93ep-120))
(assert_return (invoke "no_demote_mixed_add" (f64.const -0x1.0d5110e3385bbp-20) (f32.const 0x1.096f4ap-29)) (f32.const -0x1.0ccc5ap-20))
(assert_return (invoke "no_demote_mixed_add" (f64.const -0x1.73852db4e5075p-20) (f32.const -0x1.24e474p-41)) (f32.const -0x1.738536p-20))

(assert_return (invoke "no_demote_mixed_add_commuted" (f32.const 0x1.3f4e9cp-119) (f64.const 0x1.f51a9d04854f9p-95)) (f32.const 0x1.f51a9ep-95))
(assert_return (invoke "no_demote_mixed_add_commuted" (f32.const 0x1.758cd8p+38) (f64.const 0x1.065b3d81ad8dp+37)) (f32.const 0x1.f8ba76p+38))
(assert_return (invoke "no_demote_mixed_add_commuted" (f32.const -0x1.9bbf86p-121) (f64.const 0x1.626c80963bd17p-119)) (f32.const 0x1.f6f93ep-120))
(assert_return (invoke "no_demote_mixed_add_commuted" (f32.const 0x1.096f4ap-29) (f64.const -0x1.0d5110e3385bbp-20)) (f32.const -0x1.0ccc5ap-20))
(assert_return (invoke "no_demote_mixed_add_commuted" (f32.const -0x1.24e474p-41) (f64.const -0x1.73852db4e5075p-20)) (f32.const -0x1.738536p-20))

;; Test that demote(x-promote(y)) is not folded to demote(x)-y.

(module
  (type (;0;) (func (param f64 f32) (result f32)))
  (type (;1;) (func (param i64)))
  (type (;2;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 1)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 2)))
  (func (;2;) (type 0) (param $x f64) (param $y f32) (result f32)
    i64.const 16
    i64.const 1
    call 1
    i64.const 6
    call 0
    local.get $x
    local.get $y
    f64.promote_f32
    f64.sub
    f32.demote_f64
  )
  (export "no_demote_mixed_sub" (func 2))
)
(assert_return (invoke "no_demote_mixed_sub" (f64.const 0x1.a0a183220e9b1p+82) (f32.const 0x1.c5acf8p+61)) (f32.const 0x1.a0a174p+82))
(assert_return (invoke "no_demote_mixed_sub" (f64.const -0x1.6e2c5ac39f63ep+30) (f32.const 0x1.d48ca4p+17)) (f32.const -0x1.6e3bp+30))
(assert_return (invoke "no_demote_mixed_sub" (f64.const -0x1.98c74350dde6ap+6) (f32.const 0x1.9d69bcp-12)) (f32.const -0x1.98c7aap+6))
(assert_return (invoke "no_demote_mixed_sub" (f64.const 0x1.0459f34091dbfp-54) (f32.const 0x1.61ad08p-71)) (f32.const 0x1.045942p-54))
(assert_return (invoke "no_demote_mixed_sub" (f64.const 0x1.a7498dca3fdb7p+14) (f32.const 0x1.ed21c8p+15)) (f32.const -0x1.197d02p+15))

;; Test that converting between integer and float and back isn't folded away.

(module
  (type (;0;) (func (param f32) (result f32)))
  (type (;1;) (func (param f64) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (result f32)
    i64.const 4
    i64.const 0
    call 1
    i64.const 2
    call 0
    local.get $x
    i32.trunc_f32_s
    i64.const 2
    call 0
    f32.convert_i32_s
  )
  (func (;3;) (type 0) (param $x f32) (result f32)
    i64.const 4
    i64.const 0
    call 1
    i64.const 2
    call 0
    local.get $x
    i32.trunc_f32_u
    i64.const 2
    call 0
    f32.convert_i32_s
  )
  (func (;4;) (type 0) (param $x f32) (result f32)
    i64.const 4
    i64.const 0
    call 1
    i64.const 2
    call 0
    local.get $x
    i32.trunc_f32_s
    i64.const 2
    call 0
    f32.convert_i32_u
  )
  (func (;5;) (type 0) (param $x f32) (result f32)
    i64.const 4
    i64.const 0
    call 1
    i64.const 2
    call 0
    local.get $x
    i32.trunc_f32_u
    i64.const 2
    call 0
    f32.convert_i32_u
  )
  (func (;6;) (type 1) (param $x f64) (result f64)
    i64.const 8
    i64.const 0
    call 1
    i64.const 2
    call 0
    local.get $x
    i32.trunc_f64_s
    i64.const 2
    call 0
    f64.convert_i32_s
  )
  (func (;7;) (type 1) (param $x f64) (result f64)
    i64.const 8
    i64.const 0
    call 1
    i64.const 2
    call 0
    local.get $x
    i32.trunc_f64_u
    i64.const 2
    call 0
    f64.convert_i32_s
  )
  (func (;8;) (type 1) (param $x f64) (result f64)
    i64.const 8
    i64.const 0
    call 1
    i64.const 2
    call 0
    local.get $x
    i32.trunc_f64_s
    i64.const 2
    call 0
    f64.convert_i32_u
  )
  (func (;9;) (type 1) (param $x f64) (result f64)
    i64.const 8
    i64.const 0
    call 1
    i64.const 2
    call 0
    local.get $x
    i32.trunc_f64_u
    i64.const 2
    call 0
    f64.convert_i32_u
  )
  (func (;10;) (type 0) (param $x f32) (result f32)
    i64.const 8
    i64.const 0
    call 1
    i64.const 2
    call 0
    local.get $x
    i64.trunc_f32_s
    i64.const 2
    call 0
    f32.convert_i64_s
  )
  (func (;11;) (type 0) (param $x f32) (result f32)
    i64.const 8
    i64.const 0
    call 1
    i64.const 2
    call 0
    local.get $x
    i64.trunc_f32_u
    i64.const 2
    call 0
    f32.convert_i64_s
  )
  (func (;12;) (type 0) (param $x f32) (result f32)
    i64.const 8
    i64.const 0
    call 1
    i64.const 2
    call 0
    local.get $x
    i64.trunc_f32_s
    i64.const 2
    call 0
    f32.convert_i64_u
  )
  (func (;13;) (type 0) (param $x f32) (result f32)
    i64.const 8
    i64.const 0
    call 1
    i64.const 2
    call 0
    local.get $x
    i64.trunc_f32_u
    i64.const 2
    call 0
    f32.convert_i64_u
  )
  (func (;14;) (type 1) (param $x f64) (result f64)
    i64.const 8
    i64.const 0
    call 1
    i64.const 2
    call 0
    local.get $x
    i64.trunc_f64_s
    i64.const 2
    call 0
    f64.convert_i64_s
  )
  (func (;15;) (type 1) (param $x f64) (result f64)
    i64.const 8
    i64.const 0
    call 1
    i64.const 2
    call 0
    local.get $x
    i64.trunc_f64_u
    i64.const 2
    call 0
    f64.convert_i64_s
  )
  (func (;16;) (type 1) (param $x f64) (result f64)
    i64.const 8
    i64.const 0
    call 1
    i64.const 2
    call 0
    local.get $x
    i64.trunc_f64_s
    i64.const 2
    call 0
    f64.convert_i64_u
  )
  (func (;17;) (type 1) (param $x f64) (result f64)
    i64.const 8
    i64.const 0
    call 1
    i64.const 2
    call 0
    local.get $x
    i64.trunc_f64_u
    i64.const 2
    call 0
    f64.convert_i64_u
  )
  (export "f32.i32.no_fold_trunc_s_convert_s" (func 2))
  (export "f32.i32.no_fold_trunc_u_convert_s" (func 3))
  (export "f32.i32.no_fold_trunc_s_convert_u" (func 4))
  (export "f32.i32.no_fold_trunc_u_convert_u" (func 5))
  (export "f64.i32.no_fold_trunc_s_convert_s" (func 6))
  (export "f64.i32.no_fold_trunc_u_convert_s" (func 7))
  (export "f64.i32.no_fold_trunc_s_convert_u" (func 8))
  (export "f64.i32.no_fold_trunc_u_convert_u" (func 9))
  (export "f32.i64.no_fold_trunc_s_convert_s" (func 10))
  (export "f32.i64.no_fold_trunc_u_convert_s" (func 11))
  (export "f32.i64.no_fold_trunc_s_convert_u" (func 12))
  (export "f32.i64.no_fold_trunc_u_convert_u" (func 13))
  (export "f64.i64.no_fold_trunc_s_convert_s" (func 14))
  (export "f64.i64.no_fold_trunc_u_convert_s" (func 15))
  (export "f64.i64.no_fold_trunc_s_convert_u" (func 16))
  (export "f64.i64.no_fold_trunc_u_convert_u" (func 17))
)
(assert_return (invoke "f32.i32.no_fold_trunc_s_convert_s" (f32.const 1.5)) (f32.const 1.0))
(assert_return (invoke "f32.i32.no_fold_trunc_s_convert_s" (f32.const -1.5)) (f32.const -1.0))
(assert_return (invoke "f32.i32.no_fold_trunc_u_convert_s" (f32.const 1.5)) (f32.const 1.0))
(assert_return (invoke "f32.i32.no_fold_trunc_u_convert_s" (f32.const -0.5)) (f32.const 0.0))
(assert_return (invoke "f32.i32.no_fold_trunc_s_convert_u" (f32.const 1.5)) (f32.const 1.0))
(assert_return (invoke "f32.i32.no_fold_trunc_s_convert_u" (f32.const -1.5)) (f32.const 0x1p+32))
(assert_return (invoke "f32.i32.no_fold_trunc_u_convert_u" (f32.const 1.5)) (f32.const 1.0))
(assert_return (invoke "f32.i32.no_fold_trunc_u_convert_u" (f32.const -0.5)) (f32.const 0.0))

(assert_return (invoke "f64.i32.no_fold_trunc_s_convert_s" (f64.const 1.5)) (f64.const 1.0))
(assert_return (invoke "f64.i32.no_fold_trunc_s_convert_s" (f64.const -1.5)) (f64.const -1.0))
(assert_return (invoke "f64.i32.no_fold_trunc_u_convert_s" (f64.const 1.5)) (f64.const 1.0))
(assert_return (invoke "f64.i32.no_fold_trunc_u_convert_s" (f64.const -0.5)) (f64.const 0.0))
(assert_return (invoke "f64.i32.no_fold_trunc_s_convert_u" (f64.const 1.5)) (f64.const 1.0))
(assert_return (invoke "f64.i32.no_fold_trunc_s_convert_u" (f64.const -1.5)) (f64.const 0x1.fffffffep+31))
(assert_return (invoke "f64.i32.no_fold_trunc_u_convert_u" (f64.const 1.5)) (f64.const 1.0))
(assert_return (invoke "f64.i32.no_fold_trunc_u_convert_u" (f64.const -0.5)) (f64.const 0.0))

(assert_return (invoke "f32.i64.no_fold_trunc_s_convert_s" (f32.const 1.5)) (f32.const 1.0))
(assert_return (invoke "f32.i64.no_fold_trunc_s_convert_s" (f32.const -1.5)) (f32.const -1.0))
(assert_return (invoke "f32.i64.no_fold_trunc_u_convert_s" (f32.const 1.5)) (f32.const 1.0))
(assert_return (invoke "f32.i64.no_fold_trunc_u_convert_s" (f32.const -0.5)) (f32.const 0.0))
(assert_return (invoke "f32.i64.no_fold_trunc_s_convert_u" (f32.const 1.5)) (f32.const 1.0))
(assert_return (invoke "f32.i64.no_fold_trunc_s_convert_u" (f32.const -1.5)) (f32.const 0x1p+64))
(assert_return (invoke "f32.i64.no_fold_trunc_u_convert_u" (f32.const 1.5)) (f32.const 1.0))
(assert_return (invoke "f32.i64.no_fold_trunc_u_convert_u" (f32.const -0.5)) (f32.const 0.0))

(assert_return (invoke "f64.i64.no_fold_trunc_s_convert_s" (f64.const 1.5)) (f64.const 1.0))
(assert_return (invoke "f64.i64.no_fold_trunc_s_convert_s" (f64.const -1.5)) (f64.const -1.0))
(assert_return (invoke "f64.i64.no_fold_trunc_u_convert_s" (f64.const 1.5)) (f64.const 1.0))
(assert_return (invoke "f64.i64.no_fold_trunc_u_convert_s" (f64.const -0.5)) (f64.const 0.0))
(assert_return (invoke "f64.i64.no_fold_trunc_s_convert_u" (f64.const 1.5)) (f64.const 1.0))
(assert_return (invoke "f64.i64.no_fold_trunc_s_convert_u" (f64.const -1.5)) (f64.const 0x1p+64))
(assert_return (invoke "f64.i64.no_fold_trunc_u_convert_u" (f64.const 1.5)) (f64.const 1.0))
(assert_return (invoke "f64.i64.no_fold_trunc_u_convert_u" (f64.const -0.5)) (f64.const 0.0))

;; Test that dividing by a loop-invariant constant isn't optimized to be a
;; multiplication by a reciprocal, which would be particularly tempting since
;; the reciprocal computation could be hoisted.

(module
  (type (;0;) (func (param i32 f32)))
  (type (;1;) (func (param i32) (result f32)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $i i32) (param $x f32)
    i64.const 8
    i64.const 1
    call 1
    i64.const 3
    call 0
    local.get $i
    local.get $x
    f32.store
    i64.const 1
    call 0
  )
  (func (;3;) (type 0) (param $n i32) (param $z f32)
    (local $i i32)
    i64.const 12
    i64.const 2
    call 1
    i64.const 2
    call 0
    block $exit ;; label = @1
      loop $cont ;; label = @2
        i64.const 3
        call 0
        local.get $i
        local.get $i
        f32.load
        i64.const 3
        call 0
        local.get $z
        f32.div
        f32.store
        i64.const 8
        call 0
        local.get $i
        i32.const 4
        i32.add
        local.set $i
        local.get $i
        local.get $n
        i32.lt_u
        br_if 0 (;@2;)
        i64.const 3
        call 0
      end
    end
  )
  (func (;4;) (type 1) (param $i i32) (result f32)
    i64.const 4
    i64.const 0
    call 1
    i64.const 2
    call 0
    local.get $i
    f32.load
    i64.const 1
    call 0
  )
  (memory (;0;) 1 1)
  (export "init" (func 2))
  (export "run" (func 3))
  (export "check" (func 4))
)
(invoke "init" (i32.const  0) (f32.const 15.1))
(invoke "init" (i32.const  4) (f32.const 15.2))
(invoke "init" (i32.const  8) (f32.const 15.3))
(invoke "init" (i32.const 12) (f32.const 15.4))
(assert_return (invoke "check" (i32.const  0)) (f32.const 15.1))
(assert_return (invoke "check" (i32.const  4)) (f32.const 15.2))
(assert_return (invoke "check" (i32.const  8)) (f32.const 15.3))
(assert_return (invoke "check" (i32.const 12)) (f32.const 15.4))
(invoke "run" (i32.const 16) (f32.const 3.0))
(assert_return (invoke "check" (i32.const  0)) (f32.const 0x1.422222p+2))
(assert_return (invoke "check" (i32.const  4)) (f32.const 0x1.444444p+2))
(assert_return (invoke "check" (i32.const  8)) (f32.const 0x1.466666p+2))
(assert_return (invoke "check" (i32.const 12)) (f32.const 0x1.488888p+2))

(module
  (type (;0;) (func (param i32 f64)))
  (type (;1;) (func (param i32) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $i i32) (param $x f64)
    i64.const 12
    i64.const 1
    call 1
    i64.const 3
    call 0
    local.get $i
    local.get $x
    f64.store
    i64.const 1
    call 0
  )
  (func (;3;) (type 0) (param $n i32) (param $z f64)
    (local $i i32)
    i64.const 20
    i64.const 2
    call 1
    i64.const 2
    call 0
    block $exit ;; label = @1
      loop $cont ;; label = @2
        i64.const 3
        call 0
        local.get $i
        local.get $i
        f64.load
        i64.const 3
        call 0
        local.get $z
        f64.div
        f64.store
        i64.const 8
        call 0
        local.get $i
        i32.const 8
        i32.add
        local.set $i
        local.get $i
        local.get $n
        i32.lt_u
        br_if 0 (;@2;)
        i64.const 3
        call 0
      end
    end
  )
  (func (;4;) (type 1) (param $i i32) (result f64)
    i64.const 8
    i64.const 0
    call 1
    i64.const 2
    call 0
    local.get $i
    f64.load
    i64.const 1
    call 0
  )
  (memory (;0;) 1 1)
  (export "init" (func 2))
  (export "run" (func 3))
  (export "check" (func 4))
)
(invoke "init" (i32.const  0) (f64.const 15.1))
(invoke "init" (i32.const  8) (f64.const 15.2))
(invoke "init" (i32.const 16) (f64.const 15.3))
(invoke "init" (i32.const 24) (f64.const 15.4))
(assert_return (invoke "check" (i32.const  0)) (f64.const 15.1))
(assert_return (invoke "check" (i32.const  8)) (f64.const 15.2))
(assert_return (invoke "check" (i32.const 16)) (f64.const 15.3))
(assert_return (invoke "check" (i32.const 24)) (f64.const 15.4))
(invoke "run" (i32.const 32) (f64.const 3.0))
(assert_return (invoke "check" (i32.const 0)) (f64.const 0x1.4222222222222p+2))
(assert_return (invoke "check" (i32.const 8)) (f64.const 0x1.4444444444444p+2))
(assert_return (invoke "check" (i32.const 16)) (f64.const 0x1.4666666666667p+2))
(assert_return (invoke "check" (i32.const 24)) (f64.const 0x1.4888888888889p+2))

;; Test that ult/ugt/etc. aren't folded to olt/ogt/etc.

(module
  (type (;0;) (func (param f32 f32) (result i32)))
  (type (;1;) (func (param f64 f64) (result i32)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (param $y f32) (result i32)
    i64.const 8
    i64.const 1
    call 1
    i64.const 5
    call 0
    local.get $x
    local.get $y
    f32.ge
    i32.eqz
  )
  (func (;3;) (type 0) (param $x f32) (param $y f32) (result i32)
    i64.const 8
    i64.const 1
    call 1
    i64.const 5
    call 0
    local.get $x
    local.get $y
    f32.gt
    i32.eqz
  )
  (func (;4;) (type 0) (param $x f32) (param $y f32) (result i32)
    i64.const 8
    i64.const 1
    call 1
    i64.const 5
    call 0
    local.get $x
    local.get $y
    f32.le
    i32.eqz
  )
  (func (;5;) (type 0) (param $x f32) (param $y f32) (result i32)
    i64.const 8
    i64.const 1
    call 1
    i64.const 5
    call 0
    local.get $x
    local.get $y
    f32.lt
    i32.eqz
  )
  (func (;6;) (type 1) (param $x f64) (param $y f64) (result i32)
    i64.const 16
    i64.const 1
    call 1
    i64.const 5
    call 0
    local.get $x
    local.get $y
    f64.ge
    i32.eqz
  )
  (func (;7;) (type 1) (param $x f64) (param $y f64) (result i32)
    i64.const 16
    i64.const 1
    call 1
    i64.const 5
    call 0
    local.get $x
    local.get $y
    f64.gt
    i32.eqz
  )
  (func (;8;) (type 1) (param $x f64) (param $y f64) (result i32)
    i64.const 16
    i64.const 1
    call 1
    i64.const 5
    call 0
    local.get $x
    local.get $y
    f64.le
    i32.eqz
  )
  (func (;9;) (type 1) (param $x f64) (param $y f64) (result i32)
    i64.const 16
    i64.const 1
    call 1
    i64.const 5
    call 0
    local.get $x
    local.get $y
    f64.lt
    i32.eqz
  )
  (export "f32.ult" (func 2))
  (export "f32.ule" (func 3))
  (export "f32.ugt" (func 4))
  (export "f32.uge" (func 5))
  (export "f64.ult" (func 6))
  (export "f64.ule" (func 7))
  (export "f64.ugt" (func 8))
  (export "f64.uge" (func 9))
)
(assert_return (invoke "f32.ult" (f32.const 3.0) (f32.const 2.0)) (i32.const 0))
(assert_return (invoke "f32.ult" (f32.const 2.0) (f32.const 2.0)) (i32.const 0))
(assert_return (invoke "f32.ult" (f32.const 2.0) (f32.const 3.0)) (i32.const 1))
(assert_return (invoke "f32.ult" (f32.const 2.0) (f32.const nan)) (i32.const 1))
(assert_return (invoke "f32.ule" (f32.const 3.0) (f32.const 2.0)) (i32.const 0))
(assert_return (invoke "f32.ule" (f32.const 2.0) (f32.const 2.0)) (i32.const 1))
(assert_return (invoke "f32.ule" (f32.const 2.0) (f32.const 3.0)) (i32.const 1))
(assert_return (invoke "f32.ule" (f32.const 2.0) (f32.const nan)) (i32.const 1))
(assert_return (invoke "f32.ugt" (f32.const 3.0) (f32.const 2.0)) (i32.const 1))
(assert_return (invoke "f32.ugt" (f32.const 2.0) (f32.const 2.0)) (i32.const 0))
(assert_return (invoke "f32.ugt" (f32.const 2.0) (f32.const 3.0)) (i32.const 0))
(assert_return (invoke "f32.ugt" (f32.const 2.0) (f32.const nan)) (i32.const 1))
(assert_return (invoke "f32.uge" (f32.const 3.0) (f32.const 2.0)) (i32.const 1))
(assert_return (invoke "f32.uge" (f32.const 2.0) (f32.const 2.0)) (i32.const 1))
(assert_return (invoke "f32.uge" (f32.const 2.0) (f32.const 3.0)) (i32.const 0))
(assert_return (invoke "f32.uge" (f32.const 2.0) (f32.const nan)) (i32.const 1))
(assert_return (invoke "f64.ult" (f64.const 3.0) (f64.const 2.0)) (i32.const 0))
(assert_return (invoke "f64.ult" (f64.const 2.0) (f64.const 2.0)) (i32.const 0))
(assert_return (invoke "f64.ult" (f64.const 2.0) (f64.const 3.0)) (i32.const 1))
(assert_return (invoke "f64.ult" (f64.const 2.0) (f64.const nan)) (i32.const 1))
(assert_return (invoke "f64.ule" (f64.const 3.0) (f64.const 2.0)) (i32.const 0))
(assert_return (invoke "f64.ule" (f64.const 2.0) (f64.const 2.0)) (i32.const 1))
(assert_return (invoke "f64.ule" (f64.const 2.0) (f64.const 3.0)) (i32.const 1))
(assert_return (invoke "f64.ule" (f64.const 2.0) (f64.const nan)) (i32.const 1))
(assert_return (invoke "f64.ugt" (f64.const 3.0) (f64.const 2.0)) (i32.const 1))
(assert_return (invoke "f64.ugt" (f64.const 2.0) (f64.const 2.0)) (i32.const 0))
(assert_return (invoke "f64.ugt" (f64.const 2.0) (f64.const 3.0)) (i32.const 0))
(assert_return (invoke "f64.ugt" (f64.const 2.0) (f64.const nan)) (i32.const 1))
(assert_return (invoke "f64.uge" (f64.const 3.0) (f64.const 2.0)) (i32.const 1))
(assert_return (invoke "f64.uge" (f64.const 2.0) (f64.const 2.0)) (i32.const 1))
(assert_return (invoke "f64.uge" (f64.const 2.0) (f64.const 3.0)) (i32.const 0))
(assert_return (invoke "f64.uge" (f64.const 2.0) (f64.const nan)) (i32.const 1))

;; Test that x<y?x:y, etc. using select aren't folded to min, etc.

(module
  (type (;0;) (func (param f32 f32) (result f32)))
  (type (;1;) (func (param f64 f64) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (param $y f32) (result f32)
    i64.const 16
    i64.const 1
    call 1
    i64.const 7
    call 0
    local.get $x
    local.get $y
    local.get $x
    local.get $y
    f32.lt
    select
  )
  (func (;3;) (type 0) (param $x f32) (param $y f32) (result f32)
    i64.const 16
    i64.const 1
    call 1
    i64.const 7
    call 0
    local.get $x
    local.get $y
    local.get $x
    local.get $y
    f32.le
    select
  )
  (func (;4;) (type 0) (param $x f32) (param $y f32) (result f32)
    i64.const 16
    i64.const 1
    call 1
    i64.const 7
    call 0
    local.get $x
    local.get $y
    local.get $x
    local.get $y
    f32.gt
    select
  )
  (func (;5;) (type 0) (param $x f32) (param $y f32) (result f32)
    i64.const 16
    i64.const 1
    call 1
    i64.const 7
    call 0
    local.get $x
    local.get $y
    local.get $x
    local.get $y
    f32.ge
    select
  )
  (func (;6;) (type 1) (param $x f64) (param $y f64) (result f64)
    i64.const 32
    i64.const 1
    call 1
    i64.const 7
    call 0
    local.get $x
    local.get $y
    local.get $x
    local.get $y
    f64.lt
    select
  )
  (func (;7;) (type 1) (param $x f64) (param $y f64) (result f64)
    i64.const 32
    i64.const 1
    call 1
    i64.const 7
    call 0
    local.get $x
    local.get $y
    local.get $x
    local.get $y
    f64.le
    select
  )
  (func (;8;) (type 1) (param $x f64) (param $y f64) (result f64)
    i64.const 32
    i64.const 1
    call 1
    i64.const 7
    call 0
    local.get $x
    local.get $y
    local.get $x
    local.get $y
    f64.gt
    select
  )
  (func (;9;) (type 1) (param $x f64) (param $y f64) (result f64)
    i64.const 32
    i64.const 1
    call 1
    i64.const 7
    call 0
    local.get $x
    local.get $y
    local.get $x
    local.get $y
    f64.ge
    select
  )
  (export "f32.no_fold_lt_select" (func 2))
  (export "f32.no_fold_le_select" (func 3))
  (export "f32.no_fold_gt_select" (func 4))
  (export "f32.no_fold_ge_select" (func 5))
  (export "f64.no_fold_lt_select" (func 6))
  (export "f64.no_fold_le_select" (func 7))
  (export "f64.no_fold_gt_select" (func 8))
  (export "f64.no_fold_ge_select" (func 9))
)
(assert_return (invoke "f32.no_fold_lt_select" (f32.const 0.0) (f32.const nan)) (f32.const nan))
(assert_return (invoke "f32.no_fold_lt_select" (f32.const nan) (f32.const 0.0)) (f32.const 0.0))
(assert_return (invoke "f32.no_fold_lt_select" (f32.const 0.0) (f32.const -0.0)) (f32.const -0.0))
(assert_return (invoke "f32.no_fold_lt_select" (f32.const -0.0) (f32.const 0.0)) (f32.const 0.0))
(assert_return (invoke "f32.no_fold_le_select" (f32.const 0.0) (f32.const nan)) (f32.const nan))
(assert_return (invoke "f32.no_fold_le_select" (f32.const nan) (f32.const 0.0)) (f32.const 0.0))
(assert_return (invoke "f32.no_fold_le_select" (f32.const 0.0) (f32.const -0.0)) (f32.const 0.0))
(assert_return (invoke "f32.no_fold_le_select" (f32.const -0.0) (f32.const 0.0)) (f32.const -0.0))
(assert_return (invoke "f32.no_fold_gt_select" (f32.const 0.0) (f32.const nan)) (f32.const nan))
(assert_return (invoke "f32.no_fold_gt_select" (f32.const nan) (f32.const 0.0)) (f32.const 0.0))
(assert_return (invoke "f32.no_fold_gt_select" (f32.const 0.0) (f32.const -0.0)) (f32.const -0.0))
(assert_return (invoke "f32.no_fold_gt_select" (f32.const -0.0) (f32.const 0.0)) (f32.const 0.0))
(assert_return (invoke "f32.no_fold_ge_select" (f32.const 0.0) (f32.const nan)) (f32.const nan))
(assert_return (invoke "f32.no_fold_ge_select" (f32.const nan) (f32.const 0.0)) (f32.const 0.0))
(assert_return (invoke "f32.no_fold_ge_select" (f32.const 0.0) (f32.const -0.0)) (f32.const 0.0))
(assert_return (invoke "f32.no_fold_ge_select" (f32.const -0.0) (f32.const 0.0)) (f32.const -0.0))
(assert_return (invoke "f64.no_fold_lt_select" (f64.const 0.0) (f64.const nan)) (f64.const nan))
(assert_return (invoke "f64.no_fold_lt_select" (f64.const nan) (f64.const 0.0)) (f64.const 0.0))
(assert_return (invoke "f64.no_fold_lt_select" (f64.const 0.0) (f64.const -0.0)) (f64.const -0.0))
(assert_return (invoke "f64.no_fold_lt_select" (f64.const -0.0) (f64.const 0.0)) (f64.const 0.0))
(assert_return (invoke "f64.no_fold_le_select" (f64.const 0.0) (f64.const nan)) (f64.const nan))
(assert_return (invoke "f64.no_fold_le_select" (f64.const nan) (f64.const 0.0)) (f64.const 0.0))
(assert_return (invoke "f64.no_fold_le_select" (f64.const 0.0) (f64.const -0.0)) (f64.const 0.0))
(assert_return (invoke "f64.no_fold_le_select" (f64.const -0.0) (f64.const 0.0)) (f64.const -0.0))
(assert_return (invoke "f64.no_fold_gt_select" (f64.const 0.0) (f64.const nan)) (f64.const nan))
(assert_return (invoke "f64.no_fold_gt_select" (f64.const nan) (f64.const 0.0)) (f64.const 0.0))
(assert_return (invoke "f64.no_fold_gt_select" (f64.const 0.0) (f64.const -0.0)) (f64.const -0.0))
(assert_return (invoke "f64.no_fold_gt_select" (f64.const -0.0) (f64.const 0.0)) (f64.const 0.0))
(assert_return (invoke "f64.no_fold_ge_select" (f64.const 0.0) (f64.const nan)) (f64.const nan))
(assert_return (invoke "f64.no_fold_ge_select" (f64.const nan) (f64.const 0.0)) (f64.const 0.0))
(assert_return (invoke "f64.no_fold_ge_select" (f64.const 0.0) (f64.const -0.0)) (f64.const 0.0))
(assert_return (invoke "f64.no_fold_ge_select" (f64.const -0.0) (f64.const 0.0)) (f64.const -0.0))

;; Test that x<y?x:y, etc. using if and else aren't folded to min, etc.

(module
  (type (;0;) (func (param f32 f32) (result f32)))
  (type (;1;) (func (param f64 f64) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (param $y f32) (result f32)
    i64.const 8
    i64.const 1
    call 1
    i64.const 4
    call 0
    local.get $x
    local.get $y
    f32.lt
    if (result f32) ;; label = @1
      i64.const 2
      call 0
      local.get $x
    else
      i64.const 2
      call 0
      local.get $y
    end
    i64.const 1
    call 0
  )
  (func (;3;) (type 0) (param $x f32) (param $y f32) (result f32)
    i64.const 8
    i64.const 1
    call 1
    i64.const 4
    call 0
    local.get $x
    local.get $y
    f32.le
    if (result f32) ;; label = @1
      i64.const 2
      call 0
      local.get $x
    else
      i64.const 2
      call 0
      local.get $y
    end
    i64.const 1
    call 0
  )
  (func (;4;) (type 0) (param $x f32) (param $y f32) (result f32)
    i64.const 8
    i64.const 1
    call 1
    i64.const 4
    call 0
    local.get $x
    local.get $y
    f32.gt
    if (result f32) ;; label = @1
      i64.const 2
      call 0
      local.get $x
    else
      i64.const 2
      call 0
      local.get $y
    end
    i64.const 1
    call 0
  )
  (func (;5;) (type 0) (param $x f32) (param $y f32) (result f32)
    i64.const 8
    i64.const 1
    call 1
    i64.const 4
    call 0
    local.get $x
    local.get $y
    f32.ge
    if (result f32) ;; label = @1
      i64.const 2
      call 0
      local.get $x
    else
      i64.const 2
      call 0
      local.get $y
    end
    i64.const 1
    call 0
  )
  (func (;6;) (type 1) (param $x f64) (param $y f64) (result f64)
    i64.const 16
    i64.const 1
    call 1
    i64.const 4
    call 0
    local.get $x
    local.get $y
    f64.lt
    if (result f64) ;; label = @1
      i64.const 2
      call 0
      local.get $x
    else
      i64.const 2
      call 0
      local.get $y
    end
    i64.const 1
    call 0
  )
  (func (;7;) (type 1) (param $x f64) (param $y f64) (result f64)
    i64.const 16
    i64.const 1
    call 1
    i64.const 4
    call 0
    local.get $x
    local.get $y
    f64.le
    if (result f64) ;; label = @1
      i64.const 2
      call 0
      local.get $x
    else
      i64.const 2
      call 0
      local.get $y
    end
    i64.const 1
    call 0
  )
  (func (;8;) (type 1) (param $x f64) (param $y f64) (result f64)
    i64.const 16
    i64.const 1
    call 1
    i64.const 4
    call 0
    local.get $x
    local.get $y
    f64.gt
    if (result f64) ;; label = @1
      i64.const 2
      call 0
      local.get $x
    else
      i64.const 2
      call 0
      local.get $y
    end
    i64.const 1
    call 0
  )
  (func (;9;) (type 1) (param $x f64) (param $y f64) (result f64)
    i64.const 16
    i64.const 1
    call 1
    i64.const 4
    call 0
    local.get $x
    local.get $y
    f64.ge
    if (result f64) ;; label = @1
      i64.const 2
      call 0
      local.get $x
    else
      i64.const 2
      call 0
      local.get $y
    end
    i64.const 1
    call 0
  )
  (export "f32.no_fold_lt_if" (func 2))
  (export "f32.no_fold_le_if" (func 3))
  (export "f32.no_fold_gt_if" (func 4))
  (export "f32.no_fold_ge_if" (func 5))
  (export "f64.no_fold_lt_if" (func 6))
  (export "f64.no_fold_le_if" (func 7))
  (export "f64.no_fold_gt_if" (func 8))
  (export "f64.no_fold_ge_if" (func 9))
)
(assert_return (invoke "f32.no_fold_lt_if" (f32.const 0.0) (f32.const nan)) (f32.const nan))
(assert_return (invoke "f32.no_fold_lt_if" (f32.const nan) (f32.const 0.0)) (f32.const 0.0))
(assert_return (invoke "f32.no_fold_lt_if" (f32.const 0.0) (f32.const -0.0)) (f32.const -0.0))
(assert_return (invoke "f32.no_fold_lt_if" (f32.const -0.0) (f32.const 0.0)) (f32.const 0.0))
(assert_return (invoke "f32.no_fold_le_if" (f32.const 0.0) (f32.const nan)) (f32.const nan))
(assert_return (invoke "f32.no_fold_le_if" (f32.const nan) (f32.const 0.0)) (f32.const 0.0))
(assert_return (invoke "f32.no_fold_le_if" (f32.const 0.0) (f32.const -0.0)) (f32.const 0.0))
(assert_return (invoke "f32.no_fold_le_if" (f32.const -0.0) (f32.const 0.0)) (f32.const -0.0))
(assert_return (invoke "f32.no_fold_gt_if" (f32.const 0.0) (f32.const nan)) (f32.const nan))
(assert_return (invoke "f32.no_fold_gt_if" (f32.const nan) (f32.const 0.0)) (f32.const 0.0))
(assert_return (invoke "f32.no_fold_gt_if" (f32.const 0.0) (f32.const -0.0)) (f32.const -0.0))
(assert_return (invoke "f32.no_fold_gt_if" (f32.const -0.0) (f32.const 0.0)) (f32.const 0.0))
(assert_return (invoke "f32.no_fold_ge_if" (f32.const 0.0) (f32.const nan)) (f32.const nan))
(assert_return (invoke "f32.no_fold_ge_if" (f32.const nan) (f32.const 0.0)) (f32.const 0.0))
(assert_return (invoke "f32.no_fold_ge_if" (f32.const 0.0) (f32.const -0.0)) (f32.const 0.0))
(assert_return (invoke "f32.no_fold_ge_if" (f32.const -0.0) (f32.const 0.0)) (f32.const -0.0))
(assert_return (invoke "f64.no_fold_lt_if" (f64.const 0.0) (f64.const nan)) (f64.const nan))
(assert_return (invoke "f64.no_fold_lt_if" (f64.const nan) (f64.const 0.0)) (f64.const 0.0))
(assert_return (invoke "f64.no_fold_lt_if" (f64.const 0.0) (f64.const -0.0)) (f64.const -0.0))
(assert_return (invoke "f64.no_fold_lt_if" (f64.const -0.0) (f64.const 0.0)) (f64.const 0.0))
(assert_return (invoke "f64.no_fold_le_if" (f64.const 0.0) (f64.const nan)) (f64.const nan))
(assert_return (invoke "f64.no_fold_le_if" (f64.const nan) (f64.const 0.0)) (f64.const 0.0))
(assert_return (invoke "f64.no_fold_le_if" (f64.const 0.0) (f64.const -0.0)) (f64.const 0.0))
(assert_return (invoke "f64.no_fold_le_if" (f64.const -0.0) (f64.const 0.0)) (f64.const -0.0))
(assert_return (invoke "f64.no_fold_gt_if" (f64.const 0.0) (f64.const nan)) (f64.const nan))
(assert_return (invoke "f64.no_fold_gt_if" (f64.const nan) (f64.const 0.0)) (f64.const 0.0))
(assert_return (invoke "f64.no_fold_gt_if" (f64.const 0.0) (f64.const -0.0)) (f64.const -0.0))
(assert_return (invoke "f64.no_fold_gt_if" (f64.const -0.0) (f64.const 0.0)) (f64.const 0.0))
(assert_return (invoke "f64.no_fold_ge_if" (f64.const 0.0) (f64.const nan)) (f64.const nan))
(assert_return (invoke "f64.no_fold_ge_if" (f64.const nan) (f64.const 0.0)) (f64.const 0.0))
(assert_return (invoke "f64.no_fold_ge_if" (f64.const 0.0) (f64.const -0.0)) (f64.const 0.0))
(assert_return (invoke "f64.no_fold_ge_if" (f64.const -0.0) (f64.const 0.0)) (f64.const -0.0))

;; Test that x<0?-x:x, etc. using select aren't folded to abs.

(module
  (type (;0;) (func (param f32) (result f32)))
  (type (;1;) (func (param f64) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (result f32)
    i64.const 16
    i64.const 0
    call 1
    i64.const 8
    call 0
    local.get $x
    f32.neg
    local.get $x
    local.get $x
    f32.const 0x0p+0 (;=0;)
    f32.lt
    select
  )
  (func (;3;) (type 0) (param $x f32) (result f32)
    i64.const 16
    i64.const 0
    call 1
    i64.const 8
    call 0
    local.get $x
    f32.neg
    local.get $x
    local.get $x
    f32.const -0x0p+0 (;=-0;)
    f32.le
    select
  )
  (func (;4;) (type 0) (param $x f32) (result f32)
    i64.const 16
    i64.const 0
    call 1
    i64.const 8
    call 0
    local.get $x
    local.get $x
    f32.neg
    local.get $x
    f32.const -0x0p+0 (;=-0;)
    f32.gt
    select
  )
  (func (;5;) (type 0) (param $x f32) (result f32)
    i64.const 16
    i64.const 0
    call 1
    i64.const 8
    call 0
    local.get $x
    local.get $x
    f32.neg
    local.get $x
    f32.const 0x0p+0 (;=0;)
    f32.ge
    select
  )
  (func (;6;) (type 1) (param $x f64) (result f64)
    i64.const 32
    i64.const 0
    call 1
    i64.const 8
    call 0
    local.get $x
    f64.neg
    local.get $x
    local.get $x
    f64.const 0x0p+0 (;=0;)
    f64.lt
    select
  )
  (func (;7;) (type 1) (param $x f64) (result f64)
    i64.const 32
    i64.const 0
    call 1
    i64.const 8
    call 0
    local.get $x
    f64.neg
    local.get $x
    local.get $x
    f64.const -0x0p+0 (;=-0;)
    f64.le
    select
  )
  (func (;8;) (type 1) (param $x f64) (result f64)
    i64.const 32
    i64.const 0
    call 1
    i64.const 8
    call 0
    local.get $x
    local.get $x
    f64.neg
    local.get $x
    f64.const -0x0p+0 (;=-0;)
    f64.gt
    select
  )
  (func (;9;) (type 1) (param $x f64) (result f64)
    i64.const 32
    i64.const 0
    call 1
    i64.const 8
    call 0
    local.get $x
    local.get $x
    f64.neg
    local.get $x
    f64.const 0x0p+0 (;=0;)
    f64.ge
    select
  )
  (export "f32.no_fold_lt_select_to_abs" (func 2))
  (export "f32.no_fold_le_select_to_abs" (func 3))
  (export "f32.no_fold_gt_select_to_abs" (func 4))
  (export "f32.no_fold_ge_select_to_abs" (func 5))
  (export "f64.no_fold_lt_select_to_abs" (func 6))
  (export "f64.no_fold_le_select_to_abs" (func 7))
  (export "f64.no_fold_gt_select_to_abs" (func 8))
  (export "f64.no_fold_ge_select_to_abs" (func 9))
)
(assert_return (invoke "f32.no_fold_lt_select_to_abs" (f32.const nan:0x200000)) (f32.const nan:0x200000))
(assert_return (invoke "f32.no_fold_lt_select_to_abs" (f32.const -nan)) (f32.const -nan))
(assert_return (invoke "f32.no_fold_lt_select_to_abs" (f32.const 0.0)) (f32.const 0.0))
(assert_return (invoke "f32.no_fold_lt_select_to_abs" (f32.const -0.0)) (f32.const -0.0))
(assert_return (invoke "f32.no_fold_le_select_to_abs" (f32.const nan:0x200000)) (f32.const nan:0x200000))
(assert_return (invoke "f32.no_fold_le_select_to_abs" (f32.const -nan)) (f32.const -nan))
(assert_return (invoke "f32.no_fold_le_select_to_abs" (f32.const 0.0)) (f32.const -0.0))
(assert_return (invoke "f32.no_fold_le_select_to_abs" (f32.const -0.0)) (f32.const 0.0))
(assert_return (invoke "f32.no_fold_gt_select_to_abs" (f32.const nan:0x200000)) (f32.const -nan:0x200000))
(assert_return (invoke "f32.no_fold_gt_select_to_abs" (f32.const -nan)) (f32.const nan))
(assert_return (invoke "f32.no_fold_gt_select_to_abs" (f32.const 0.0)) (f32.const -0.0))
(assert_return (invoke "f32.no_fold_gt_select_to_abs" (f32.const -0.0)) (f32.const 0.0))
(assert_return (invoke "f32.no_fold_ge_select_to_abs" (f32.const nan:0x200000)) (f32.const -nan:0x200000))
(assert_return (invoke "f32.no_fold_ge_select_to_abs" (f32.const -nan)) (f32.const nan))
(assert_return (invoke "f32.no_fold_ge_select_to_abs" (f32.const 0.0)) (f32.const 0.0))
(assert_return (invoke "f32.no_fold_ge_select_to_abs" (f32.const -0.0)) (f32.const -0.0))
(assert_return (invoke "f64.no_fold_lt_select_to_abs" (f64.const nan:0x4000000000000)) (f64.const nan:0x4000000000000))
(assert_return (invoke "f64.no_fold_lt_select_to_abs" (f64.const -nan)) (f64.const -nan))
(assert_return (invoke "f64.no_fold_lt_select_to_abs" (f64.const 0.0)) (f64.const 0.0))
(assert_return (invoke "f64.no_fold_lt_select_to_abs" (f64.const -0.0)) (f64.const -0.0))
(assert_return (invoke "f64.no_fold_le_select_to_abs" (f64.const nan:0x4000000000000)) (f64.const nan:0x4000000000000))
(assert_return (invoke "f64.no_fold_le_select_to_abs" (f64.const -nan)) (f64.const -nan))
(assert_return (invoke "f64.no_fold_le_select_to_abs" (f64.const 0.0)) (f64.const -0.0))
(assert_return (invoke "f64.no_fold_le_select_to_abs" (f64.const -0.0)) (f64.const 0.0))
(assert_return (invoke "f64.no_fold_gt_select_to_abs" (f64.const nan:0x4000000000000)) (f64.const -nan:0x4000000000000))
(assert_return (invoke "f64.no_fold_gt_select_to_abs" (f64.const -nan)) (f64.const nan))
(assert_return (invoke "f64.no_fold_gt_select_to_abs" (f64.const 0.0)) (f64.const -0.0))
(assert_return (invoke "f64.no_fold_gt_select_to_abs" (f64.const -0.0)) (f64.const 0.0))
(assert_return (invoke "f64.no_fold_ge_select_to_abs" (f64.const nan:0x4000000000000)) (f64.const -nan:0x4000000000000))
(assert_return (invoke "f64.no_fold_ge_select_to_abs" (f64.const -nan)) (f64.const nan))
(assert_return (invoke "f64.no_fold_ge_select_to_abs" (f64.const 0.0)) (f64.const 0.0))
(assert_return (invoke "f64.no_fold_ge_select_to_abs" (f64.const -0.0)) (f64.const -0.0))

;; Test that x<0?-x:x, etc. using if aren't folded to abs.

(module
  (type (;0;) (func (param f32) (result f32)))
  (type (;1;) (func (param f64) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (result f32)
    i64.const 8
    i64.const 0
    call 1
    i64.const 4
    call 0
    local.get $x
    f32.const 0x0p+0 (;=0;)
    f32.lt
    if (result f32) ;; label = @1
      i64.const 3
      call 0
      local.get $x
      f32.neg
    else
      i64.const 2
      call 0
      local.get $x
    end
    i64.const 1
    call 0
  )
  (func (;3;) (type 0) (param $x f32) (result f32)
    i64.const 8
    i64.const 0
    call 1
    i64.const 4
    call 0
    local.get $x
    f32.const -0x0p+0 (;=-0;)
    f32.le
    if (result f32) ;; label = @1
      i64.const 3
      call 0
      local.get $x
      f32.neg
    else
      i64.const 2
      call 0
      local.get $x
    end
    i64.const 1
    call 0
  )
  (func (;4;) (type 0) (param $x f32) (result f32)
    i64.const 8
    i64.const 0
    call 1
    i64.const 4
    call 0
    local.get $x
    f32.const -0x0p+0 (;=-0;)
    f32.gt
    if (result f32) ;; label = @1
      i64.const 2
      call 0
      local.get $x
    else
      i64.const 3
      call 0
      local.get $x
      f32.neg
    end
    i64.const 1
    call 0
  )
  (func (;5;) (type 0) (param $x f32) (result f32)
    i64.const 8
    i64.const 0
    call 1
    i64.const 4
    call 0
    local.get $x
    f32.const 0x0p+0 (;=0;)
    f32.ge
    if (result f32) ;; label = @1
      i64.const 2
      call 0
      local.get $x
    else
      i64.const 3
      call 0
      local.get $x
      f32.neg
    end
    i64.const 1
    call 0
  )
  (func (;6;) (type 1) (param $x f64) (result f64)
    i64.const 16
    i64.const 0
    call 1
    i64.const 4
    call 0
    local.get $x
    f64.const 0x0p+0 (;=0;)
    f64.lt
    if (result f64) ;; label = @1
      i64.const 3
      call 0
      local.get $x
      f64.neg
    else
      i64.const 2
      call 0
      local.get $x
    end
    i64.const 1
    call 0
  )
  (func (;7;) (type 1) (param $x f64) (result f64)
    i64.const 16
    i64.const 0
    call 1
    i64.const 4
    call 0
    local.get $x
    f64.const -0x0p+0 (;=-0;)
    f64.le
    if (result f64) ;; label = @1
      i64.const 3
      call 0
      local.get $x
      f64.neg
    else
      i64.const 2
      call 0
      local.get $x
    end
    i64.const 1
    call 0
  )
  (func (;8;) (type 1) (param $x f64) (result f64)
    i64.const 16
    i64.const 0
    call 1
    i64.const 4
    call 0
    local.get $x
    f64.const -0x0p+0 (;=-0;)
    f64.gt
    if (result f64) ;; label = @1
      i64.const 2
      call 0
      local.get $x
    else
      i64.const 3
      call 0
      local.get $x
      f64.neg
    end
    i64.const 1
    call 0
  )
  (func (;9;) (type 1) (param $x f64) (result f64)
    i64.const 16
    i64.const 0
    call 1
    i64.const 4
    call 0
    local.get $x
    f64.const 0x0p+0 (;=0;)
    f64.ge
    if (result f64) ;; label = @1
      i64.const 2
      call 0
      local.get $x
    else
      i64.const 3
      call 0
      local.get $x
      f64.neg
    end
    i64.const 1
    call 0
  )
  (export "f32.no_fold_lt_if_to_abs" (func 2))
  (export "f32.no_fold_le_if_to_abs" (func 3))
  (export "f32.no_fold_gt_if_to_abs" (func 4))
  (export "f32.no_fold_ge_if_to_abs" (func 5))
  (export "f64.no_fold_lt_if_to_abs" (func 6))
  (export "f64.no_fold_le_if_to_abs" (func 7))
  (export "f64.no_fold_gt_if_to_abs" (func 8))
  (export "f64.no_fold_ge_if_to_abs" (func 9))
)
(assert_return (invoke "f32.no_fold_lt_if_to_abs" (f32.const nan:0x200000)) (f32.const nan:0x200000))
(assert_return (invoke "f32.no_fold_lt_if_to_abs" (f32.const -nan)) (f32.const -nan))
(assert_return (invoke "f32.no_fold_lt_if_to_abs" (f32.const 0.0)) (f32.const 0.0))
(assert_return (invoke "f32.no_fold_lt_if_to_abs" (f32.const -0.0)) (f32.const -0.0))
(assert_return (invoke "f32.no_fold_le_if_to_abs" (f32.const nan:0x200000)) (f32.const nan:0x200000))
(assert_return (invoke "f32.no_fold_le_if_to_abs" (f32.const -nan)) (f32.const -nan))
(assert_return (invoke "f32.no_fold_le_if_to_abs" (f32.const 0.0)) (f32.const -0.0))
(assert_return (invoke "f32.no_fold_le_if_to_abs" (f32.const -0.0)) (f32.const 0.0))
(assert_return (invoke "f32.no_fold_gt_if_to_abs" (f32.const nan:0x200000)) (f32.const -nan:0x200000))
(assert_return (invoke "f32.no_fold_gt_if_to_abs" (f32.const -nan)) (f32.const nan))
(assert_return (invoke "f32.no_fold_gt_if_to_abs" (f32.const 0.0)) (f32.const -0.0))
(assert_return (invoke "f32.no_fold_gt_if_to_abs" (f32.const -0.0)) (f32.const 0.0))
(assert_return (invoke "f32.no_fold_ge_if_to_abs" (f32.const nan:0x200000)) (f32.const -nan:0x200000))
(assert_return (invoke "f32.no_fold_ge_if_to_abs" (f32.const -nan)) (f32.const nan))
(assert_return (invoke "f32.no_fold_ge_if_to_abs" (f32.const 0.0)) (f32.const 0.0))
(assert_return (invoke "f32.no_fold_ge_if_to_abs" (f32.const -0.0)) (f32.const -0.0))
(assert_return (invoke "f64.no_fold_lt_if_to_abs" (f64.const nan:0x4000000000000)) (f64.const nan:0x4000000000000))
(assert_return (invoke "f64.no_fold_lt_if_to_abs" (f64.const -nan)) (f64.const -nan))
(assert_return (invoke "f64.no_fold_lt_if_to_abs" (f64.const 0.0)) (f64.const 0.0))
(assert_return (invoke "f64.no_fold_lt_if_to_abs" (f64.const -0.0)) (f64.const -0.0))
(assert_return (invoke "f64.no_fold_le_if_to_abs" (f64.const nan:0x4000000000000)) (f64.const nan:0x4000000000000))
(assert_return (invoke "f64.no_fold_le_if_to_abs" (f64.const -nan)) (f64.const -nan))
(assert_return (invoke "f64.no_fold_le_if_to_abs" (f64.const 0.0)) (f64.const -0.0))
(assert_return (invoke "f64.no_fold_le_if_to_abs" (f64.const -0.0)) (f64.const 0.0))
(assert_return (invoke "f64.no_fold_gt_if_to_abs" (f64.const nan:0x4000000000000)) (f64.const -nan:0x4000000000000))
(assert_return (invoke "f64.no_fold_gt_if_to_abs" (f64.const -nan)) (f64.const nan))
(assert_return (invoke "f64.no_fold_gt_if_to_abs" (f64.const 0.0)) (f64.const -0.0))
(assert_return (invoke "f64.no_fold_gt_if_to_abs" (f64.const -0.0)) (f64.const 0.0))
(assert_return (invoke "f64.no_fold_ge_if_to_abs" (f64.const nan:0x4000000000000)) (f64.const -nan:0x4000000000000))
(assert_return (invoke "f64.no_fold_ge_if_to_abs" (f64.const -nan)) (f64.const nan))
(assert_return (invoke "f64.no_fold_ge_if_to_abs" (f64.const 0.0)) (f64.const 0.0))
(assert_return (invoke "f64.no_fold_ge_if_to_abs" (f64.const -0.0)) (f64.const -0.0))

;; Test for a historic spreadsheet bug.
;; https://support.microsoft.com/en-us/kb/78113

(module
  (type (;0;) (func (result f32)))
  (type (;1;) (func (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (result f32)
    i64.const 8
    i64.const 0
    call 1
    i64.const 8
    call 0
    f32.const 0x1.553f7cp+0 (;=1.333;)
    f32.const 0x1.39999ap+0 (;=1.225;)
    f32.add
    f32.const 0x1.553f7cp+0 (;=1.333;)
    f32.sub
    f32.const 0x1.39999ap+0 (;=1.225;)
    f32.sub
  )
  (func (;3;) (type 1) (result f64)
    i64.const 16
    i64.const 0
    call 1
    i64.const 8
    call 0
    f64.const 0x1.553f7ced91687p+0 (;=1.333;)
    f64.const 0x1.399999999999ap+0 (;=1.225;)
    f64.add
    f64.const 0x1.553f7ced91687p+0 (;=1.333;)
    f64.sub
    f64.const 0x1.399999999999ap+0 (;=1.225;)
    f64.sub
  )
  (export "f32.incorrect_correction" (func 2))
  (export "f64.incorrect_correction" (func 3))
)
(assert_return (invoke "f32.incorrect_correction") (f32.const 0x1p-23))
(assert_return (invoke "f64.incorrect_correction") (f64.const -0x1p-52))

;; Test for a historical calculator bug.
;; http://www.hpmuseum.org/cgi-sys/cgiwrap/hpmuseum/articles.cgi?read=735

(module
  (type (;0;) (func (result f32)))
  (type (;1;) (func (param i64)))
  (type (;2;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 1)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 2)))
  (func (;2;) (type 0) (result f32)
    (local $x f32) (local $r f32) (local $q f32) (local $z0 f32) (local $z1 f32)
    i64.const 12
    i64.const 4
    call 1
    i64.const 33
    call 0
    f32.const 0x1.388p+7 (;=156.25;)
    local.set $x
    f32.const 0x1.a0aaaap+7 (;=208.33333;)
    local.set $r
    f32.const 0x1.c78e2ap+0 (;=1.779513;)
    local.set $q
    local.get $r
    f32.neg
    local.get $x
    f32.mul
    local.get $x
    local.get $q
    f32.mul
    local.get $r
    f32.sub
    f32.div
    local.set $z0
    local.get $r
    f32.neg
    local.get $x
    f32.mul
    local.get $x
    local.get $q
    f32.mul
    local.get $r
    f32.sub
    f32.div
    local.set $z1
    block ;; label = @1
      local.get $z0
      local.get $z1
      f32.eq
      br_if 0 (;@1;)
      i64.const 1
      call 0
      unreachable
      i64.const 1
      call 0
    end
    i64.const 2
    call 0
    local.get $z1
  )
  (export "calculate" (func 2))
)
(assert_return (invoke "calculate") (f32.const -0x1.d2ed46p+8))

(module
  (type (;0;) (func (result f64)))
  (type (;1;) (func (param i64)))
  (type (;2;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 1)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 2)))
  (func (;2;) (type 0) (result f64)
    (local $x f64) (local $r f64) (local $q f64) (local $z0 f64) (local $z1 f64)
    i64.const 24
    i64.const 4
    call 1
    i64.const 33
    call 0
    f64.const 0x1.388p+7 (;=156.25;)
    local.set $x
    f64.const 0x1.a0aaaaaab064bp+7 (;=208.333333334;)
    local.set $r
    f64.const 0x1.c78e2aae3d096p+0 (;=1.77951304201;)
    local.set $q
    local.get $r
    f64.neg
    local.get $x
    f64.mul
    local.get $x
    local.get $q
    f64.mul
    local.get $r
    f64.sub
    f64.div
    local.set $z0
    local.get $r
    f64.neg
    local.get $x
    f64.mul
    local.get $x
    local.get $q
    f64.mul
    local.get $r
    f64.sub
    f64.div
    local.set $z1
    block ;; label = @1
      local.get $z0
      local.get $z1
      f64.eq
      br_if 0 (;@1;)
      i64.const 1
      call 0
      unreachable
      i64.const 1
      call 0
    end
    i64.const 2
    call 0
    local.get $z1
  )
  (export "calculate" (func 2))
)
(assert_return (invoke "calculate") (f64.const -0x1.d2ed4d0218c93p+8))

;; Test that 0 - (-0 - x) is not optimized to x.
;; https://llvm.org/bugs/show_bug.cgi?id=26746

(module
  (type (;0;) (func (param f32) (result f32)))
  (type (;1;) (func (param i64)))
  (type (;2;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 1)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 2)))
  (func (;2;) (type 0) (param $x f32) (result f32)
    i64.const 12
    i64.const 0
    call 1
    i64.const 6
    call 0
    f32.const 0x0p+0 (;=0;)
    f32.const -0x0p+0 (;=-0;)
    local.get $x
    f32.sub
    f32.sub
  )
  (export "llvm_pr26746" (func 2))
)
(assert_return (invoke "llvm_pr26746" (f32.const -0.0)) (f32.const 0.0))

;; Test for improperly reassociating an addition and a conversion.
;; https://llvm.org/bugs/show_bug.cgi?id=27153

(module
  (type (;0;) (func (param i32) (result f32)))
  (type (;1;) (func (param i64)))
  (type (;2;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 1)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 2)))
  (func (;2;) (type 0) (param $x i32) (result f32)
    i64.const 8
    i64.const 0
    call 1
    i64.const 7
    call 0
    local.get $x
    i32.const 268435455
    i32.and
    f32.convert_i32_s
    f32.const -0x1p+23 (;=-8388608;)
    f32.add
  )
  (export "llvm_pr27153" (func 2))
)
(assert_return (invoke "llvm_pr27153" (i32.const 33554434)) (f32.const 25165824.000000))

;; Test that (float)x + (float)y is not optimized to (float)(x + y) when unsafe.
;; https://llvm.org/bugs/show_bug.cgi?id=27036

(module
  (type (;0;) (func (param i32 i32) (result f32)))
  (type (;1;) (func (param i64)))
  (type (;2;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 1)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 2)))
  (func (;2;) (type 0) (param $x i32) (param $y i32) (result f32)
    i64.const 12
    i64.const 1
    call 1
    i64.const 10
    call 0
    local.get $x
    i32.const -25034805
    i32.or
    f32.convert_i32_s
    local.get $y
    i32.const 14942208
    i32.and
    f32.convert_i32_s
    f32.add
  )
  (export "llvm_pr27036" (func 2))
)
(assert_return (invoke "llvm_pr27036" (i32.const -25034805) (i32.const 14942208)) (f32.const -0x1.340068p+23))

;; Test for bugs in old versions of historic IEEE 754 platforms as reported in:
;;
;; N. L. Schryer. 1981. A Test of a Computer's Floating-Point Arithmetic Unit.
;; Tech. Rep. Computer Science Technical Report 89, AT&T Bell Laboratories, Feb.
;;
;; specifically, the appendices describing IEEE systems with "The Past" sections
;; describing specific bugs. The 0 < 0 bug is omitted here due to being already
;; covered elsewhere.
(module
  (type (;0;) (func (param f64 f64 f64 f64) (result f64)))
  (type (;1;) (func (param f64 f64 f64) (result f64)))
  (type (;2;) (func (param f32 f32 f32) (result f32)))
  (type (;3;) (func (param i64)))
  (type (;4;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 3)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 4)))
  (func (;2;) (type 0) (param $a f64) (param $b f64) (param $c f64) (param $d f64) (result f64)
    i64.const 24
    i64.const 3
    call 1
    i64.const 8
    call 0
    local.get $a
    local.get $b
    f64.mul
    local.get $c
    local.get $d
    f64.mul
    f64.div
  )
  (func (;3;) (type 1) (param $a f64) (param $b f64) (param $c f64) (result f64)
    i64.const 16
    i64.const 2
    call 1
    i64.const 6
    call 0
    local.get $a
    local.get $b
    f64.mul
    local.get $c
    f64.sub
  )
  (func (;4;) (type 2) (param $a f32) (param $b f32) (param $c f32) (result f32)
    i64.const 8
    i64.const 2
    call 1
    i64.const 6
    call 0
    local.get $a
    local.get $b
    f32.mul
    local.get $c
    f32.mul
  )
  (export "thepast0" (func 2))
  (export "thepast1" (func 3))
  (export "thepast2" (func 4))
)
(assert_return (invoke "thepast0" (f64.const 0x1p-1021) (f64.const 0x1.fffffffffffffp-1) (f64.const 0x1p1) (f64.const 0x1p-1)) (f64.const 0x1.fffffffffffffp-1022))
(assert_return (invoke "thepast1" (f64.const 0x1p-54) (f64.const 0x1.fffffffffffffp-1) (f64.const 0x1p-54)) (f64.const -0x1p-107))
(assert_return (invoke "thepast2" (f32.const 0x1p-125) (f32.const 0x1p-1) (f32.const 0x1p0)) (f32.const 0x1p-126))

;; Test for floating point tolerances observed in some GPUs.
;; https://community.amd.com/thread/145582

(module
  (type (;0;) (func (param f32) (result f32)))
  (type (;1;) (func (param i64)))
  (type (;2;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 1)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 2)))
  (func (;2;) (type 0) (param $x f32) (result f32)
    i64.const 8
    i64.const 0
    call 1
    i64.const 4
    call 0
    f32.const 0x1p+0 (;=1;)
    local.get $x
    f32.div
  )
  (export "inverse" (func 2))
)
(assert_return (invoke "inverse" (f32.const 96.0)) (f32.const 0x1.555556p-7))

;; Test for incorrect rounding on sqrt(4.0).
;; http://www.askvg.com/microsoft-windows-calculator-bug/

(module
  (type (;0;) (func (param f32) (result f32)))
  (type (;1;) (func (param f64) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (result f32)
    i64.const 8
    i64.const 0
    call 1
    i64.const 5
    call 0
    local.get $x
    f32.sqrt
    f32.const 0x1p+1 (;=2;)
    f32.sub
  )
  (func (;3;) (type 1) (param $x f64) (result f64)
    i64.const 16
    i64.const 0
    call 1
    i64.const 5
    call 0
    local.get $x
    f64.sqrt
    f64.const 0x1p+1 (;=2;)
    f64.sub
  )
  (export "f32_sqrt_minus_2" (func 2))
  (export "f64_sqrt_minus_2" (func 3))
)
(assert_return (invoke "f32_sqrt_minus_2" (f32.const 4.0)) (f32.const 0.0))
(assert_return (invoke "f64_sqrt_minus_2" (f64.const 4.0)) (f64.const 0.0))

;; Test that 1.0 / (1.0 / x) is not optimized to x.

(module
  (type (;0;) (func (param f32) (result f32)))
  (type (;1;) (func (param f64) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (result f32)
    i64.const 12
    i64.const 0
    call 1
    i64.const 6
    call 0
    f32.const 0x1p+0 (;=1;)
    f32.const 0x1p+0 (;=1;)
    local.get $x
    f32.div
    f32.div
  )
  (func (;3;) (type 1) (param $x f64) (result f64)
    i64.const 24
    i64.const 0
    call 1
    i64.const 6
    call 0
    f64.const 0x1p+0 (;=1;)
    f64.const 0x1p+0 (;=1;)
    local.get $x
    f64.div
    f64.div
  )
  (export "f32.no_fold_recip_recip" (func 2))
  (export "f64.no_fold_recip_recip" (func 3))
)
(assert_return (invoke "f32.no_fold_recip_recip" (f32.const -0x1.e8bf18p+65)) (f32.const -0x1.e8bf16p+65))
(assert_return (invoke "f32.no_fold_recip_recip" (f32.const 0x1.e24248p-77)) (f32.const 0x1.e24246p-77))
(assert_return (invoke "f32.no_fold_recip_recip" (f32.const 0x1.caf0e8p-64)) (f32.const 0x1.caf0eap-64))
(assert_return (invoke "f32.no_fold_recip_recip" (f32.const -0x1.e66982p+4)) (f32.const -0x1.e66984p+4))
(assert_return (invoke "f32.no_fold_recip_recip" (f32.const 0x1.f99916p+70)) (f32.const 0x1.f99914p+70))

(assert_return (invoke "f32.no_fold_recip_recip" (f32.const -0x0p+0)) (f32.const -0x0p+0))
(assert_return (invoke "f32.no_fold_recip_recip" (f32.const 0x0p+0)) (f32.const 0x0p+0))
(assert_return (invoke "f32.no_fold_recip_recip" (f32.const -inf)) (f32.const -inf))
(assert_return (invoke "f32.no_fold_recip_recip" (f32.const inf)) (f32.const inf))

(assert_return (invoke "f64.no_fold_recip_recip" (f64.const -0x1.d81248dda63dp+148)) (f64.const -0x1.d81248dda63d1p+148))
(assert_return (invoke "f64.no_fold_recip_recip" (f64.const -0x1.f4750312039e3p+66)) (f64.const -0x1.f4750312039e2p+66))
(assert_return (invoke "f64.no_fold_recip_recip" (f64.const 0x1.fa50630eec7f6p+166)) (f64.const 0x1.fa50630eec7f5p+166))
(assert_return (invoke "f64.no_fold_recip_recip" (f64.const 0x1.db0598617ba92p-686)) (f64.const 0x1.db0598617ba91p-686))
(assert_return (invoke "f64.no_fold_recip_recip" (f64.const 0x1.85f1638a0c82bp+902)) (f64.const 0x1.85f1638a0c82ap+902))

(assert_return (invoke "f64.no_fold_recip_recip" (f64.const -0x0p+0)) (f64.const -0x0p+0))
(assert_return (invoke "f64.no_fold_recip_recip" (f64.const 0x0p+0)) (f64.const 0x0p+0))
(assert_return (invoke "f64.no_fold_recip_recip" (f64.const -inf)) (f64.const -inf))
(assert_return (invoke "f64.no_fold_recip_recip" (f64.const inf)) (f64.const inf))

;; Test that (x+y) * (x-y) is not optimized to x*x - y*y.

(module
  (type (;0;) (func (param f32 f32) (result f32)))
  (type (;1;) (func (param f64 f64) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (param $y f32) (result f32)
    i64.const 12
    i64.const 1
    call 1
    i64.const 8
    call 0
    local.get $x
    local.get $y
    f32.add
    local.get $x
    local.get $y
    f32.sub
    f32.mul
  )
  (func (;3;) (type 1) (param $x f64) (param $y f64) (result f64)
    i64.const 24
    i64.const 1
    call 1
    i64.const 8
    call 0
    local.get $x
    local.get $y
    f64.add
    local.get $x
    local.get $y
    f64.sub
    f64.mul
  )
  (export "f32.no_algebraic_factoring" (func 2))
  (export "f64.no_algebraic_factoring" (func 3))
)
(assert_return (invoke "f32.no_algebraic_factoring" (f32.const -0x1.ef678ep-55) (f32.const 0x1.c160b8p-54)) (f32.const -0x1.129402p-107))
(assert_return (invoke "f32.no_algebraic_factoring" (f32.const -0x1.2d76bcp+24) (f32.const 0x1.f4089cp+24)) (f32.const -0x1.36d89ap+49))
(assert_return (invoke "f32.no_algebraic_factoring" (f32.const 0x1.7ca2b2p+45) (f32.const -0x1.08513cp+47)) (f32.const -0x1.db10dep+93))
(assert_return (invoke "f32.no_algebraic_factoring" (f32.const 0x1.7d5e3p+17) (f32.const -0x1.c783b4p+7)) (f32.const 0x1.1c10a6p+35))
(assert_return (invoke "f32.no_algebraic_factoring" (f32.const -0x1.daf96p+7) (f32.const -0x1.dac6bp+19)) (f32.const -0x1.b8422ep+39))

(assert_return (invoke "f64.no_algebraic_factoring" (f64.const 0x1.e17c0a02ac6b5p-476) (f64.const 0x1.e8f13f1fcdc14p-463)) (f64.const -0x1.d2ec518f62863p-925))
(assert_return (invoke "f64.no_algebraic_factoring" (f64.const 0x1.971b55a57e3a3p-377) (f64.const 0x1.edeb4233c1b27p-399)) (f64.const 0x1.43b3f69fb258bp-753))
(assert_return (invoke "f64.no_algebraic_factoring" (f64.const -0x1.c3b9dc02472fap-378) (f64.const -0x1.74e9faebaff14p-369)) (f64.const -0x1.0f9c07e8caa25p-737))
(assert_return (invoke "f64.no_algebraic_factoring" (f64.const -0x1.afaf4688ed019p+179) (f64.const 0x1.b07171cb49e94p+188)) (f64.const -0x1.6d3f2e2bebcf7p+377))
(assert_return (invoke "f64.no_algebraic_factoring" (f64.const 0x1.4377a98948f12p+114) (f64.const -0x1.500c05bd24c97p+90)) (f64.const 0x1.98b72dbf7bf72p+228))

;; Test that x*x - y*y is not optimized to (x+y) * (x-y).

(module
  (type (;0;) (func (param f32 f32) (result f32)))
  (type (;1;) (func (param f64 f64) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (param $y f32) (result f32)
    i64.const 12
    i64.const 1
    call 1
    i64.const 8
    call 0
    local.get $x
    local.get $x
    f32.mul
    local.get $y
    local.get $y
    f32.mul
    f32.sub
  )
  (func (;3;) (type 1) (param $x f64) (param $y f64) (result f64)
    i64.const 24
    i64.const 1
    call 1
    i64.const 8
    call 0
    local.get $x
    local.get $x
    f64.mul
    local.get $y
    local.get $y
    f64.mul
    f64.sub
  )
  (export "f32.no_algebraic_factoring" (func 2))
  (export "f64.no_algebraic_factoring" (func 3))
)
(assert_return (invoke "f32.no_algebraic_factoring" (f32.const 0x1.8e2c14p-46) (f32.const 0x1.bad59ap-39)) (f32.const -0x1.7efe5p-77))
(assert_return (invoke "f32.no_algebraic_factoring" (f32.const -0x1.7ef192p+41) (f32.const -0x1.db184ap+33)) (f32.const 0x1.1e6932p+83))
(assert_return (invoke "f32.no_algebraic_factoring" (f32.const 0x1.7eb458p-12) (f32.const -0x1.52c498p-13)) (f32.const 0x1.cc0bc6p-24))
(assert_return (invoke "f32.no_algebraic_factoring" (f32.const 0x1.2675c6p-44) (f32.const -0x1.edd31ap-46)) (f32.const 0x1.17294cp-88))
(assert_return (invoke "f32.no_algebraic_factoring" (f32.const 0x1.9a5f92p+51) (f32.const -0x1.2b0098p+52)) (f32.const -0x1.7189a6p+103))

(assert_return (invoke "f64.no_algebraic_factoring" (f64.const 0x1.749a128f18f69p+356) (f64.const -0x1.0bc97ee1354e1p+337)) (f64.const 0x1.0f28115518d74p+713))
(assert_return (invoke "f64.no_algebraic_factoring" (f64.const -0x1.2dab01b2215eap+309) (f64.const -0x1.e12b288bff2bdp+331)) (f64.const -0x1.c4319ad25d201p+663))
(assert_return (invoke "f64.no_algebraic_factoring" (f64.const 0x1.3ed898431e102p+42) (f64.const -0x1.c409183fa92e6p+39)) (f64.const 0x1.80a611103c71dp+84))
(assert_return (invoke "f64.no_algebraic_factoring" (f64.const -0x1.be663e4c0e4b2p+182) (f64.const -0x1.da85703760d25p+166)) (f64.const 0x1.853434f1a2ffep+365))
(assert_return (invoke "f64.no_algebraic_factoring" (f64.const -0x1.230e09952df1cp-236) (f64.const -0x1.fa2752adfadc9p-237)) (f64.const 0x1.42e43156bd1b8p-474))

;; Test that platforms where SIMD instructions flush subnormals don't implicitly
;; optimize using SIMD instructions.

(module
  (type (;0;) (func (param i32 i32 i32)))
  (type (;1;) (func (param i32) (result f32)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $i i32) (param $j i32) (param $k i32)
    (local $x0 f32) (local $x1 f32) (local $x2 f32) (local $x3 f32) (local $y0 f32) (local $y1 f32) (local $y2 f32) (local $y3 f32)
    i64.const 12
    i64.const 10
    call 1
    i64.const 2
    call 0
    local.get $i
    f32.load
    i64.const 3
    call 0
    local.set $x0
    local.get $i
    f32.load offset=4
    i64.const 3
    call 0
    local.set $x1
    local.get $i
    f32.load offset=8
    i64.const 3
    call 0
    local.set $x2
    local.get $i
    f32.load offset=12
    i64.const 3
    call 0
    local.set $x3
    local.get $j
    f32.load
    i64.const 3
    call 0
    local.set $y0
    local.get $j
    f32.load offset=4
    i64.const 3
    call 0
    local.set $y1
    local.get $j
    f32.load offset=8
    i64.const 3
    call 0
    local.set $y2
    local.get $j
    f32.load offset=12
    i64.const 6
    call 0
    local.set $y3
    local.get $k
    local.get $x0
    local.get $y0
    f32.add
    f32.store
    i64.const 5
    call 0
    local.get $k
    local.get $x1
    local.get $y1
    f32.add
    f32.store offset=4
    i64.const 5
    call 0
    local.get $k
    local.get $x2
    local.get $y2
    f32.add
    f32.store offset=8
    i64.const 5
    call 0
    local.get $k
    local.get $x3
    local.get $y3
    f32.add
    f32.store offset=12
    i64.const 1
    call 0
  )
  (func (;3;) (type 1) (param $k i32) (result f32)
    i64.const 4
    i64.const 0
    call 1
    i64.const 2
    call 0
    local.get $k
    f32.load
    i64.const 1
    call 0
  )
  (memory (;0;) 1 1)
  (export "f32.simple_x4_sum" (func 2))
  (export "f32.load" (func 3))
  (data (;0;) (i32.const 0) "\01\00\00\00\01\00\00\80\01\00\00\00\01\00\00\80\01\00\00\00\01\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00")
)
(assert_return (invoke "f32.simple_x4_sum" (i32.const 0) (i32.const 16) (i32.const 32)))
(assert_return (invoke "f32.load" (i32.const 32)) (f32.const 0x1p-148))
(assert_return (invoke "f32.load" (i32.const 36)) (f32.const 0x0p+0))
(assert_return (invoke "f32.load" (i32.const 40)) (f32.const 0x1p-149))
(assert_return (invoke "f32.load" (i32.const 44)) (f32.const -0x1p-149))

(module
  (type (;0;) (func (param i32 i32 i32)))
  (type (;1;) (func (param i32) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $i i32) (param $j i32) (param $k i32)
    (local $x0 f64) (local $x1 f64) (local $x2 f64) (local $x3 f64) (local $y0 f64) (local $y1 f64) (local $y2 f64) (local $y3 f64)
    i64.const 20
    i64.const 10
    call 1
    i64.const 2
    call 0
    local.get $i
    f64.load
    i64.const 3
    call 0
    local.set $x0
    local.get $i
    f64.load offset=8
    i64.const 3
    call 0
    local.set $x1
    local.get $i
    f64.load offset=16
    i64.const 3
    call 0
    local.set $x2
    local.get $i
    f64.load offset=24
    i64.const 3
    call 0
    local.set $x3
    local.get $j
    f64.load
    i64.const 3
    call 0
    local.set $y0
    local.get $j
    f64.load offset=8
    i64.const 3
    call 0
    local.set $y1
    local.get $j
    f64.load offset=16
    i64.const 3
    call 0
    local.set $y2
    local.get $j
    f64.load offset=24
    i64.const 6
    call 0
    local.set $y3
    local.get $k
    local.get $x0
    local.get $y0
    f64.add
    f64.store
    i64.const 5
    call 0
    local.get $k
    local.get $x1
    local.get $y1
    f64.add
    f64.store offset=8
    i64.const 5
    call 0
    local.get $k
    local.get $x2
    local.get $y2
    f64.add
    f64.store offset=16
    i64.const 5
    call 0
    local.get $k
    local.get $x3
    local.get $y3
    f64.add
    f64.store offset=24
    i64.const 1
    call 0
  )
  (func (;3;) (type 1) (param $k i32) (result f64)
    i64.const 8
    i64.const 0
    call 1
    i64.const 2
    call 0
    local.get $k
    f64.load
    i64.const 1
    call 0
  )
  (memory (;0;) 1 1)
  (export "f64.simple_x4_sum" (func 2))
  (export "f64.load" (func 3))
  (data (;0;) (i32.const 0) "\01\00\00\00\00\00\00\00\01\00\00\00\00\00\00\80\01\00\00\00\00\00\00\00\01\00\00\00\00\00\00\80\01\00\00\00\00\00\00\00\01\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00")
)
(assert_return (invoke "f64.simple_x4_sum" (i32.const 0) (i32.const 32) (i32.const 64)))
(assert_return (invoke "f64.load" (i32.const 64)) (f64.const 0x0.0000000000001p-1021))
(assert_return (invoke "f64.load" (i32.const 72)) (f64.const 0x0p+0))
(assert_return (invoke "f64.load" (i32.const 80)) (f64.const 0x0.0000000000001p-1022))
(assert_return (invoke "f64.load" (i32.const 88)) (f64.const -0x0.0000000000001p-1022))

;; Test that plain summation is not reassociated, and that Kahan summation
;; isn't optimized into plain summation.

(module
  (type (;0;) (func (param i32 i32) (result f32)))
  (type (;1;) (func (param i64)))
  (type (;2;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 1)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 2)))
  (func (;2;) (type 0) (param $p i32) (param $n i32) (result f32)
    (local $sum f32) (local $c f32) (local $t f32)
    i64.const 12
    i64.const 4
    call 1
    i64.const 2
    call 0
    block $exit ;; label = @1
      loop $top ;; label = @2
        i64.const 3
        call 0
        local.get $c
        local.get $p
        f32.load
        i64.const 21
        call 0
        local.get $t
        f32.sub
        local.tee $t
        f32.add
        local.tee $sum
        local.get $c
        f32.sub
        local.get $t
        f32.sub
        local.set $t
        local.get $p
        i32.const 4
        i32.add
        local.set $p
        local.get $sum
        local.set $c
        local.get $n
        i32.const -1
        i32.add
        local.tee $n
        br_if 0 (;@2;)
        i64.const 4
        call 0
      end
    end
    local.get $sum
  )
  (func (;3;) (type 0) (param $p i32) (param $n i32) (result f32)
    (local $sum f32)
    i64.const 8
    i64.const 2
    call 1
    i64.const 2
    call 0
    block $exit ;; label = @1
      loop $top ;; label = @2
        i64.const 3
        call 0
        local.get $sum
        local.get $p
        f32.load
        i64.const 12
        call 0
        f32.add
        local.set $sum
        local.get $p
        i32.const 4
        i32.add
        local.set $p
        local.get $n
        i32.const -1
        i32.add
        local.set $n
        local.get $n
        br_if 0 (;@2;)
        i64.const 4
        call 0
      end
    end
    local.get $sum
  )
  (memory (;0;) 1 1)
  (export "f32.kahan_sum" (func 2))
  (export "f32.plain_sum" (func 3))
  (data (;0;) (i32.const 0) "\c4\c5W$\a5\84\c8\0bm\b8K.\f2v\17\1c\caJV\1e\1bnq\22]\17\1en\bf\cd\14\5c\c7!UQ9\9c\1f\b2Q\f0\a3\93\d7\c1,\ae~\a8(:\01!\f4\0aX\93\f8Bw\9f\839j_\ba\f7\0a\d8Qj4\ca\ad\c64\0e\d8&\dcL3\1c\ed)\90\a8x\0f\d1\cev1#\83\b85\e8\f2D\b0\d3\a1\fc\bb2\e1\b0\baiD\09\d6\d9}\ff.\c0Z6\143\14>\a9\fa\87m\8b\bc\ce\9d\a7\fd\c4\e9\85?\dd\d7\e1\18\a6P&rn?s\0f\f8\12\93#4av\12H\c0\9b\05\93\eb\ac\86\de\94>U\e8\8c\e8\dd\e4\fc\95G\beV\03! L\e6\bf{\f6\7f\d5\bas\1c\c1\14\8f\c4'\96\b3\bd3\ffxA_\c0Z\ce\f6gns\9a\17fp\03\f8\ce'\a3R\b2\9f;\bf\fb\ae\ed\d3Z\f87W\f0\f5n\ef\b1Mp=T\a7\01\9a\85\08H\91\f5\9d\0c`\87[\d9T\1eQm\88\8e\08\8c\a5q:V\08gF\8f\8f\13*,\ec,\1f\b4b+oA\0a\c4eB\a21k,}>\bbu\ac\86\970\d9H\cd\9a\1fV\c4\c6\e4\12\c0\9d\fb\ee\02\8c\ce\1c\f2\1e\a1x#\db\c4\1eI\03\d3q\cc\08P\c5\d8\5c\ed\d5\b5e\ac\b5\c9!\d2\c9)v\de\f00\1a[<\f2;\db:9\82:\16\08o\a8\f1\beii\99q\a6\05\d3\14\93*\16\f2/\11\c7~ \bb\91D\ee\f8\e4\01S\c0\b9\7f\f0\bf\f0\03\9cm\b1\df\a2D\01mkq+\5c\b3!\19F^\8f\db\91\d3|xk\b7\12\00\8f\eb\bd\8a\f5\d4.\c4\c1\1e\dfscYGI\03\0a\b7\cf$\cf\9c\0eDz\9e\14\fbB\bf\9d90\9e\a0\ab/\d1\ae\9ej\83C\e3U}\85\bfc\8a\f8\96\10\1f\fem\e7\22\1b\e1iF\8aD\c8\c8\f9\0c+\19\07\a5\02>\f20\10\9a\85\8a_\ef\81E\a0w\b1\03\10sK\ae\98\9dG\bf\9a-:\d5\0f\03f\e3=S\d9@\ce\1fo2/!+#!lb\d4\a7>\a8\ce(1-\00=g^\af\a0\cf.\d2\b9k\84\ebi\08<b6\be\12\fd6\7f\88>\ad\bc\0b\c0A\c4P\b6\e3P1\e8\ce\e2\96eU\9c\16F\e6\b0-:\e8\81\05\b0\bf4\f7\bc\10\1c\fb\cc<\f1\85\97B\9f\eb\14\8d<\bf\d7\17\88I\9d\8b+\b2:\83\d1O\04\9e\a1\0f\ad\08\9dT\af\d1\82\c3\ec2/\02\8f\05!-\a2\b7\e4\f4o.\81+\0b\9c\fc\cb\fet\02\f9\db\f4\f3\ea\00\a8\ec\d1\99t&\dd\d64\d5%\b1F\dd\9c\aaq\f5`\b0\88\c8\e0\0bYZ%O)f\f9\e3.\fe\e9\da\e5\18O'b\f4\ce\a4!\95t\c7Wd'\9aL\fdT}a\ce\c3\ac\87F\9c\fa\ff\09\cay\97g$t\ca\d4!\83&%\19\127d\19\e5e\e0tu\8e\dd\c8\eft\c7\d8!+y\04QFe`\03]\fa\d8\f4e\a4\9e]#\da\d7\8a\92\80\a4\dex<\f1WBm\cd\c9/\d5\a4\9e\ab@\f4\cb\1b\d7\a3\ca\fc\eb\a7\01\b2\9aiNF\9b\18N\ddy\a7\aa\a6R9\1e\ef0\cc\9b\bd[\eeL!m0\00r\b0F_\08\cf\c5\b9\e0>\c2\b3\0c\dc\8ed\de\19By\cfC\eaC]\8e\88\f7\ab\15\dc?\c8g \db\b8d\b1G\1f\de\f2\cb?Y\9f\d8F\90\dc\ae/\22\f9\e21\89\d9\9c\1cL\d3\a9JW\84\9c\9f\ea,<\ae<\c3\1e\8b\e5N\17\01%\db4F_\15\ea\05\0c|\d9E\8c\19\d0s\8a\96\16\ddD\f9\05\b7[q\b0\e6!6_u\89\91su\ab}\ae\d3s\ec7\c6\eaUu\ef\ea\ab\8b{\11\dcm\1a\b2j\c4%\cf\aa\e3\9fII\89\cb7\9b\0a\a7\01`p\dc\b7\c8\83\e1B\f5\be\adb\94\ad\8d\a1")
)
(assert_return (invoke "f32.kahan_sum" (i32.const 0) (i32.const 256)) (f32.const -0x1.101a1ap+104))
(assert_return (invoke "f32.plain_sum" (i32.const 0) (i32.const 256)) (f32.const -0x1.a0343ap+103))

(module
  (type (;0;) (func (param i32 i32) (result f64)))
  (type (;1;) (func (param i64)))
  (type (;2;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 1)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 2)))
  (func (;2;) (type 0) (param $p i32) (param $n i32) (result f64)
    (local $sum f64) (local $c f64) (local $t f64)
    i64.const 24
    i64.const 4
    call 1
    i64.const 2
    call 0
    block $exit ;; label = @1
      loop $top ;; label = @2
        i64.const 3
        call 0
        local.get $c
        local.get $p
        f64.load
        i64.const 21
        call 0
        local.get $t
        f64.sub
        local.tee $t
        f64.add
        local.tee $sum
        local.get $c
        f64.sub
        local.get $t
        f64.sub
        local.set $t
        local.get $p
        i32.const 8
        i32.add
        local.set $p
        local.get $sum
        local.set $c
        local.get $n
        i32.const -1
        i32.add
        local.tee $n
        br_if 0 (;@2;)
        i64.const 4
        call 0
      end
    end
    local.get $sum
  )
  (func (;3;) (type 0) (param $p i32) (param $n i32) (result f64)
    (local $sum f64)
    i64.const 16
    i64.const 2
    call 1
    i64.const 2
    call 0
    block $exit ;; label = @1
      loop $top ;; label = @2
        i64.const 3
        call 0
        local.get $sum
        local.get $p
        f64.load
        i64.const 12
        call 0
        f64.add
        local.set $sum
        local.get $p
        i32.const 8
        i32.add
        local.set $p
        local.get $n
        i32.const -1
        i32.add
        local.set $n
        local.get $n
        br_if 0 (;@2;)
        i64.const 4
        call 0
      end
    end
    local.get $sum
  )
  (memory (;0;) 1 1)
  (export "f64.kahan_sum" (func 2))
  (export "f64.plain_sum" (func 3))
  (data (;0;) (i32.const 0) "\13\05\84B]\a2,\c6C\dbU\a9\cd\daU\e3s\fcX\d6\ba\d5\00\fd\835B\88\8b\13]8JG\0drs\a1\1a\ef\c4E\17W\d8\c9F\e0\8dl\e17p\c8\83[U^Z-s\1eV\c8\e1mi\14x\0a\8aZd:\09\c7\a8\87\c5\f0\d3]\e6\03\fc\93\be&\ca\d6\a9\91`\bd\b0\ed\ae\f70~\92:o\a7Y\8e\aa}\bfgX*T\f8N\fe\ed5X\a6Q\bfB\e5Kf'$m\7fB-(\92\18\ec\08\ae\e7U\da\b1\a6e\a5rPG\1b\b8\a9T\d7\a6\06[\0fBX\83\8a\17\82\c6\10C\a0\c0.m\bcZ\85Sr\7f\adD\bc0<U\b2$\9at:\9e\e1\d8\0fp\fc\a9:\cd\93K\ec\e3~\dd]'\cd\f8\a0\9d\1c\11\c0W.\fd\c8\132\cc:\1a}\a3AU\ed\c3\82I*\04\1e\efs\b9..\e3_\f4\df\e6\b23\0c9?oDj\03\c1B\b9\fa\b1\c8\ed\a5X\99\7f\ed\b4r\9ey\eb\fbC\82E\aa\bb\95\d2\ff(\9e\f6\a1\ad\95\d6U\95\0do`\11\c7x>I\f2~H\f4\a2q\d0\13\8e\b3\de\99R\e3Et\eav\0e\1b*\c8\ee\14\01\c4P[6<\ef\bar\a2\a6\08\f8{6\9d\f9\ef\0b\c7V-\5c\f0\9d]\de\fc\b8\ad\0fd\0e\97\152&\c21\e6\05\1e\ef\cb\17\1bm\15\0bt]\d3.\f8k\86\b4\basRS\99\a9v E\c9@\80k\14\ed\a1\fa\80F\e6&\d2\e6\98\c4W\bf\c4\1c\a4\90z6\94\14\ba\15\89n\e6\9c7\8c\f4\de\12\22]\a1yPg\0d=z\e9\d4\aa.\7f*z0=\ea]\12H\fe\e1\18\cd\a4W\a2\87>\b6\9a\8b\db\da\9dx\9c\cf\8d\b1O\90\b44\e0\9d\f6\ca\feL;xm\0a\5c\18\9fa\b9\dd\b4\e0\0fv\e0\1bi\0d^Xsp^\0e-\a1}\ff \eb\914\92\ac8r*\1f\8eq.j\f1\af\c7'p\d9\c4W\f7\d2<\1d\b8\f0\f0d\cf\dc\ae\be\a3\cc>\22}Ni!c\17\ed\03\02T\9a\0fPN\13Z5\a1\22\a4\df\86\c2ty\16\b8ii\a0R]\11d\bd[\93\fci\a0\f4\13\d0\81Q\dd\fa\0c\15\c3z\c9bz\a9\1d\c9\e6Z\b3[\97\02<d\22\12<\22\90d-0TL\b4\a1\22\09W\22^\8e8+\02\a8\ae\f6\be\0d+\f2\03\ad\fa\10\01qw*0\02\95\f6\00>\d0\c4\8d4\19P!\0a\bcP\da<0\d6:1\94\8d:\fe\ef\14W\9dK\93\00\96$\0co\fd\bc#v\02l\ebRr\80\11~\80:\13\128\1d8I\95@'\8aD{\e8\dcm\8c\8c\8e<\b5\b3\18\0e\f6\08\1a\84A5\ff\8b\b8\93@\ea\e1Q\1d\89\a5\8dBh)\ea/\c1zR\eb\90]M\d6\80\e3\d7uH\ce\ed\d3\01\1c\8d[\a5\94\0dx\cf\f1\06\13/\98\02\a4m.l\f2\d5t)\89L\f9\03\f5\c7\18\adz\f0h\f8\5c\d6Y\87n\d6?\06\be\86 \e3A\91\22\f3n\8b\f0h\1cW\a7\fc\b0|\9e\99\0b\96\1a\89_\e6\0d|\08Q\a0\a2g\9aG\00\93k\f9(\f0h\dbb\f1\e0e,S3\e0\a7\ca\11B0\f6\af\01\c1e=2\01o\ab.\be\d3\8b\be\14\c3\ff\ec\fb\f0\f9\c5\0c\05o\01\09k\e341\0c\1ff\a6B\bc\1a\87I\16\16\8c\b0\90\0d4\8c\0a\e1\09^\10\a4kV\cc\f0\c9\bb\dc\b8\5c\ce\f6\cc\8du~\b3\07\88\04/\b4^\c9\e3J#s\19bl\9a\03vD\86\9c`\fc\dbr\8f'\a0\dd\b3\c5\da\ff\f9\ecj\b1{\d3\cfP7\c9zx\0c\e4:\b6\f5\e6\f4\98nB}5s\8bE\c0V\97\cdm\ce\cf\ad1\b3\c3T\fa\ef\d5\c0\f4j_T\e7I>3\0a08\fd\d9\05\ff\a5?WF\14\b5\91\17\cak\98#ze\b3l\02\b4\ccy]X\d8\b3\d5\94\ae\f4mue\f7\92\bf~GL<\ee\db\ac\f12]\fboA\1c4\c8\83O\c2X\01\be\05>f\16\a6\04m]O\86\09'\82%\12\cd:\cd\cek\bc\ca\ac(\9b\eej%\86\9eEp\c6\d2\bd;}B\e5'\af\c7\1d\f4\81\c8\b3v\8a\a86\a3\ae*\e6\18\e16\22\ad\f6%r\b09\8b\01\9a\22{\84\c3-_r\a4\98\ac\15p\e7\d4\18\e2}\d20|3\08\cd\ca\c4\22\85\88u\81\c6JtX\8d\e0\e8\ac\c5\abuZ\f4(\12\f0\18ER\f2\97\b2\93Ao\8d\7f\dbp\fb\a3]\1f\a7\8d\98 +\22\9f:\01\b5\8b\1b\d2\cb\14\03\0e\14\14\d2\19Z\1f\ce^\cd\81y\15\01\ca\dest\8cV \9fw-%\16\f6aQ\1d\a4\8e\9b\98\a5\c6\ec\a8EW\82Yx\0d\90\b4\dfQ\b0\c3\82\94\cc\b3S\09\15m\96l:@G\b7Jz\05/\a1\1e\8c\9d\a0 \88\fbR\b7\9f\f3\f3\bb_\e7\8aa\a7!\b1\ac\fa\09\aa\a4l\bc$\80\ba*\e9e\ffp\ff\cc\fae\87v\f3\c5\15\ce\cb\e8B1\00\0c\91W\d9\e0\9d5T$\ad\a4\d8\f9\08gc\c8\cf\81\dd\90\a2\d7\c4\07J\e6\10og\e7'\d4#Y\18\f2\a8\9d_\d8\940\aaT\86O\87\9d\82\b5&\ca\a6\96\bf\cfU\f9\9d7\01\19HC\c5\94l\f3t\97XL<\9d\08\e8\04\c2X0v\e1\a0\f8\ea\e9\c5\ae\cfx\9e\a9\0c\ac\b3DB\e0\bc]\1b\9cIXJ\1c\19I\c1:\ea\f5\eb;\81\a9Kp\0c\cc\9e\1a\d3/\b7R/ ;\ebdQ\1d\a0-\b2>\be\13\85H\922.\db\5c\a1\e7\8cE\915\01\0a\93\c2\eb\09\ce\f3\d2\22$\d0\8c\cc\1d\9d8\c8M\e3\82\ccd\15\06-\e7\01/\ab\bb\b5\04L\92\1cz\d6?\e8_1\15\0c\dc\e41\b4\c4%>*\aa\00\9e\c8\e5!z\7f)\f1\c0\af\1d^\e8c9\ad\f8~l\c8\c5\7f\c2\a8\97'\0a\d9\f4!j\ea\03\09\fb\f7\96;\83y_|K0\9fV5\de\b4s\d4\95\f0\14\c3t/\0d\a3\1dN\8d1$\b3\1a\84\85bZ{<\149\17\e6m\eb7\c2\00X[\0b\e3<\8ab\e1\f85KV\e2\87`\8b\be\a78\91wT\a9Z$%\90\9f\a5Bw\f3\5c9\df\fft\07v\a1\cd\1fb\0b\81\81h\af\05\c1\c0\7f&\ee\c0\91\a3j})aE'\e5W\88\dc\0d\97\04\1a3\a9D\8a\da\02\10E?\8eU\a6v\8cM\e3\f1\89\83\c8\d0\f8\9bPw\9fG\dfL\9cf\0d\aa\18\b8_O\c4\01\ce\dc\84\acF\9ei\e1vEka\89\e4]\94\bb\11\83\9fx\d8\0a\d2\f5~]C\ea\bc\10\f1:\c9\e2d\fbSe\d0\c7\b4\a7\fb\d4\05S%\d0\cd)\88\00V%$}]\b4\f3A\9f\e9\b5\f7\aed,\e3\c9m\d5\84:r\12\b8z\d9\1b\09\e88\da&O\04\ce\03qn\8aD{\5c\81Y\9c\d2\e4\c3\baY\a6\e5(\a7\8f\9a\e4\d5N\b9\ca\7f\cbu\b8+C>\b3\15F\b1\a5\bc\9d\9e8\15\f1\bd\1b!\aa\f1\82\00\95\fc\a7wG9\a73C\92\d7R@K\06\81\8a\a0\bd\f1k\99\84B[\e2;\c5^\12\5c(M\b6\0eN\c8\5c\e8\01\8a\c5\e7\e4\9dB\ee]\9c\c4\eb\ebh\09'\92\95\9a\11Ts\c4\12\80\fb}\fe\c5\08`\7f6A\e0\10\ba\d6+l\f1\b4\17\fe&4\e3K\f8\a8\e3\91\beO*\fc\da\81\b8\e7\fe\d5&PG\f3\1ae2\81\e0\05\b8O21&\00JS\97\c2\c3\0e.\a1&T\ab\05\8eV/}\af\22\84h\a5\8b\97\f6\a4\fd\a8\ccuA\96\86\fd'=)\86\8d\7fL\d4\8esA\f4\1e\e2\ddX'\97\ce\9c\94\cfz\04/\dc\ed")
)
(assert_return (invoke "f64.kahan_sum" (i32.const 0) (i32.const 256)) (f64.const 0x1.dd7cb2a5ffc88p+998))
(assert_return (invoke "f64.plain_sum" (i32.const 0) (i32.const 256)) (f64.const 0x1.dd7cb2a63fc87p+998))

;; Test that -(x - y) is not folded to y - x.

(module
  (type (;0;) (func (param f32 f32) (result f32)))
  (type (;1;) (func (param f64 f64) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (param $y f32) (result f32)
    i64.const 8
    i64.const 1
    call 1
    i64.const 5
    call 0
    local.get $x
    local.get $y
    f32.sub
    f32.neg
  )
  (func (;3;) (type 1) (param $x f64) (param $y f64) (result f64)
    i64.const 16
    i64.const 1
    call 1
    i64.const 5
    call 0
    local.get $x
    local.get $y
    f64.sub
    f64.neg
  )
  (export "f32.no_fold_neg_sub" (func 2))
  (export "f64.no_fold_neg_sub" (func 3))
)
(assert_return (invoke "f32.no_fold_neg_sub" (f32.const -0.0) (f32.const -0.0)) (f32.const -0.0))
(assert_return (invoke "f32.no_fold_neg_sub" (f32.const 0.0) (f32.const -0.0)) (f32.const -0.0))
(assert_return (invoke "f32.no_fold_neg_sub" (f32.const -0.0) (f32.const 0.0)) (f32.const 0.0))
(assert_return (invoke "f32.no_fold_neg_sub" (f32.const 0.0) (f32.const 0.0)) (f32.const -0.0))

(assert_return (invoke "f64.no_fold_neg_sub" (f64.const -0.0) (f64.const -0.0)) (f64.const -0.0))
(assert_return (invoke "f64.no_fold_neg_sub" (f64.const 0.0) (f64.const -0.0)) (f64.const -0.0))
(assert_return (invoke "f64.no_fold_neg_sub" (f64.const -0.0) (f64.const 0.0)) (f64.const 0.0))
(assert_return (invoke "f64.no_fold_neg_sub" (f64.const 0.0) (f64.const 0.0)) (f64.const -0.0))

;; Test that -(x + y) is not folded to (-x + -y).

(module
  (type (;0;) (func (param f32 f32) (result f32)))
  (type (;1;) (func (param f64 f64) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (param $y f32) (result f32)
    i64.const 8
    i64.const 1
    call 1
    i64.const 5
    call 0
    local.get $x
    local.get $y
    f32.add
    f32.neg
  )
  (func (;3;) (type 1) (param $x f64) (param $y f64) (result f64)
    i64.const 16
    i64.const 1
    call 1
    i64.const 5
    call 0
    local.get $x
    local.get $y
    f64.add
    f64.neg
  )
  (export "f32.no_fold_neg_add" (func 2))
  (export "f64.no_fold_neg_add" (func 3))
)
(assert_return (invoke "f32.no_fold_neg_add" (f32.const -0.0) (f32.const -0.0)) (f32.const 0.0))
(assert_return (invoke "f32.no_fold_neg_add" (f32.const 0.0) (f32.const -0.0)) (f32.const -0.0))
(assert_return (invoke "f32.no_fold_neg_add" (f32.const -0.0) (f32.const 0.0)) (f32.const -0.0))
(assert_return (invoke "f32.no_fold_neg_add" (f32.const 0.0) (f32.const 0.0)) (f32.const -0.0))

(assert_return (invoke "f64.no_fold_neg_add" (f64.const -0.0) (f64.const -0.0)) (f64.const 0.0))
(assert_return (invoke "f64.no_fold_neg_add" (f64.const 0.0) (f64.const -0.0)) (f64.const -0.0))
(assert_return (invoke "f64.no_fold_neg_add" (f64.const -0.0) (f64.const 0.0)) (f64.const -0.0))
(assert_return (invoke "f64.no_fold_neg_add" (f64.const 0.0) (f64.const 0.0)) (f64.const -0.0))

;; Test that (-x + -y) is not folded to -(x + y).

(module
  (type (;0;) (func (param f32 f32) (result f32)))
  (type (;1;) (func (param f64 f64) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (param $y f32) (result f32)
    i64.const 8
    i64.const 1
    call 1
    i64.const 6
    call 0
    local.get $x
    f32.neg
    local.get $y
    f32.neg
    f32.add
  )
  (func (;3;) (type 1) (param $x f64) (param $y f64) (result f64)
    i64.const 16
    i64.const 1
    call 1
    i64.const 6
    call 0
    local.get $x
    f64.neg
    local.get $y
    f64.neg
    f64.add
  )
  (export "f32.no_fold_add_neg_neg" (func 2))
  (export "f64.no_fold_add_neg_neg" (func 3))
)
(assert_return (invoke "f32.no_fold_add_neg_neg" (f32.const -0.0) (f32.const -0.0)) (f32.const 0.0))
(assert_return (invoke "f32.no_fold_add_neg_neg" (f32.const 0.0) (f32.const -0.0)) (f32.const 0.0))
(assert_return (invoke "f32.no_fold_add_neg_neg" (f32.const -0.0) (f32.const 0.0)) (f32.const 0.0))
(assert_return (invoke "f32.no_fold_add_neg_neg" (f32.const 0.0) (f32.const 0.0)) (f32.const -0.0))

(assert_return (invoke "f64.no_fold_add_neg_neg" (f64.const -0.0) (f64.const -0.0)) (f64.const 0.0))
(assert_return (invoke "f64.no_fold_add_neg_neg" (f64.const 0.0) (f64.const -0.0)) (f64.const 0.0))
(assert_return (invoke "f64.no_fold_add_neg_neg" (f64.const -0.0) (f64.const 0.0)) (f64.const 0.0))
(assert_return (invoke "f64.no_fold_add_neg_neg" (f64.const 0.0) (f64.const 0.0)) (f64.const -0.0))

;; Test that -x + x is not folded to 0.0.

(module
  (type (;0;) (func (param f32) (result f32)))
  (type (;1;) (func (param f64) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (result f32)
    i64.const 8
    i64.const 0
    call 1
    i64.const 5
    call 0
    local.get $x
    f32.neg
    local.get $x
    f32.add
  )
  (func (;3;) (type 1) (param $x f64) (result f64)
    i64.const 16
    i64.const 0
    call 1
    i64.const 5
    call 0
    local.get $x
    f64.neg
    local.get $x
    f64.add
  )
  (export "f32.no_fold_add_neg" (func 2))
  (export "f64.no_fold_add_neg" (func 3))
)
(assert_return (invoke "f32.no_fold_add_neg" (f32.const 0.0)) (f32.const 0.0))
(assert_return (invoke "f32.no_fold_add_neg" (f32.const -0.0)) (f32.const 0.0))
(assert_return (invoke "f32.no_fold_add_neg" (f32.const inf)) (f32.const nan:canonical))
(assert_return (invoke "f32.no_fold_add_neg" (f32.const -inf)) (f32.const nan:canonical))

(assert_return (invoke "f64.no_fold_add_neg" (f64.const 0.0)) (f64.const 0.0))
(assert_return (invoke "f64.no_fold_add_neg" (f64.const -0.0)) (f64.const 0.0))
(assert_return (invoke "f64.no_fold_add_neg" (f64.const inf)) (f64.const nan:canonical))
(assert_return (invoke "f64.no_fold_add_neg" (f64.const -inf)) (f64.const nan:canonical))

;; Test that x+x+x+x+x+x is not folded to x * 6.

(module
  (type (;0;) (func (param f32) (result f32)))
  (type (;1;) (func (param f64) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (result f32)
    i64.const 8
    i64.const 0
    call 1
    i64.const 12
    call 0
    local.get $x
    local.get $x
    f32.add
    local.get $x
    f32.add
    local.get $x
    f32.add
    local.get $x
    f32.add
    local.get $x
    f32.add
  )
  (func (;3;) (type 1) (param $x f64) (result f64)
    i64.const 16
    i64.const 0
    call 1
    i64.const 12
    call 0
    local.get $x
    local.get $x
    f64.add
    local.get $x
    f64.add
    local.get $x
    f64.add
    local.get $x
    f64.add
    local.get $x
    f64.add
  )
  (export "f32.no_fold_6x_via_add" (func 2))
  (export "f64.no_fold_6x_via_add" (func 3))
)
(assert_return (invoke "f32.no_fold_6x_via_add" (f32.const -0x1.598a0cp+99)) (f32.const -0x1.03278ap+102))
(assert_return (invoke "f32.no_fold_6x_via_add" (f32.const -0x1.d3e7acp-77)) (f32.const -0x1.5eedc2p-74))
(assert_return (invoke "f32.no_fold_6x_via_add" (f32.const 0x1.00fa02p-77)) (f32.const 0x1.817702p-75))
(assert_return (invoke "f32.no_fold_6x_via_add" (f32.const -0x1.51f434p-31)) (f32.const -0x1.faee4cp-29))
(assert_return (invoke "f32.no_fold_6x_via_add" (f32.const -0x1.00328ap+80)) (f32.const -0x1.804bcep+82))

(assert_return (invoke "f64.no_fold_6x_via_add" (f64.const -0x1.310e15acaffe6p+68)) (f64.const -0x1.c995208307fdap+70))
(assert_return (invoke "f64.no_fold_6x_via_add" (f64.const -0x1.aad62c78fa9b4p-535)) (f64.const -0x1.4020a15abbf46p-532))
(assert_return (invoke "f64.no_fold_6x_via_add" (f64.const -0x1.f8fbfa94f6ab2p+271)) (f64.const -0x1.7abcfbefb9005p+274))
(assert_return (invoke "f64.no_fold_6x_via_add" (f64.const 0x1.756ccc2830a8ep+751)) (f64.const 0x1.1811991e247ebp+754))
(assert_return (invoke "f64.no_fold_6x_via_add" (f64.const -0x1.8fd1ab1d2402ap+234)) (f64.const -0x1.2bdd4055db01fp+237))

;; Test that (x/y)/z is not optimized to x/(y*z),
;; which is an "allowable alternative Form" in Fortran.

(module
  (type (;0;) (func (param f32 f32 f32) (result f32)))
  (type (;1;) (func (param f64 f64 f64) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (param $y f32) (param $z f32) (result f32)
    i64.const 8
    i64.const 2
    call 1
    i64.const 6
    call 0
    local.get $x
    local.get $y
    f32.div
    local.get $z
    f32.div
  )
  (func (;3;) (type 1) (param $x f64) (param $y f64) (param $z f64) (result f64)
    i64.const 16
    i64.const 2
    call 1
    i64.const 6
    call 0
    local.get $x
    local.get $y
    f64.div
    local.get $z
    f64.div
  )
  (export "f32.no_fold_div_div" (func 2))
  (export "f64.no_fold_div_div" (func 3))
)
(assert_return (invoke "f32.no_fold_div_div" (f32.const -0x1.f70228p+78) (f32.const -0x1.fbc612p-16) (f32.const -0x1.8c379p+10)) (f32.const -0x1.47b43cp+83))
(assert_return (invoke "f32.no_fold_div_div" (f32.const 0x1.d29d2ep-70) (f32.const 0x1.f3a17ep+110) (f32.const -0x1.64d41p-112)) (f32.const -0x0p+0))
(assert_return (invoke "f32.no_fold_div_div" (f32.const 0x1.867f98p+43) (f32.const 0x1.30acfcp-105) (f32.const 0x1.e210d8p+105)) (f32.const inf))
(assert_return (invoke "f32.no_fold_div_div" (f32.const -0x1.c4001ap-14) (f32.const -0x1.9beb6cp+124) (f32.const -0x1.74f34cp-43)) (f32.const -0x1.819874p-96))
(assert_return (invoke "f32.no_fold_div_div" (f32.const 0x1.db0e6ep+46) (f32.const 0x1.55eea2p+56) (f32.const -0x1.f3134p+124)) (f32.const -0x1.6cep-135))

(assert_return (invoke "f64.no_fold_div_div" (f64.const 0x1.b4dc8ec3c7777p+337) (f64.const 0x1.9f95ac2d1863p+584) (f64.const -0x1.d4318abba341ep-782)) (f64.const -0x1.2649159d87e02p+534))
(assert_return (invoke "f64.no_fold_div_div" (f64.const -0x1.ac53af5eb445fp+791) (f64.const 0x1.8549c0a4ceb13p-29) (f64.const 0x1.64e384003c801p+316)) (f64.const -0x1.9417cdccbae91p+503))
(assert_return (invoke "f64.no_fold_div_div" (f64.const -0x1.d2685afb27327p+2) (f64.const -0x1.abb1eeed3dbebp+880) (f64.const 0x1.a543e2e6968a3p+170)) (f64.const 0x0.0000002a69a5fp-1022))
(assert_return (invoke "f64.no_fold_div_div" (f64.const -0x1.47ddede78ad1cp+825) (f64.const 0x1.6d932d070a367p-821) (f64.const 0x1.79cf18cc64fp+961)) (f64.const -inf))
(assert_return (invoke "f64.no_fold_div_div" (f64.const -0x1.f73d4979a9379p-888) (f64.const 0x1.4d83b53e97788p-596) (f64.const -0x1.f8f86c9603b5bp-139)) (f64.const 0x1.87a7bd89c586cp-154))

;; Test that (x/y)*(z/w) is not optimized to (x*z)/(y*w), example from
;; http://perso.ens-lyon.fr/jean-michel.muller/Handbook.html
;; section 7.4.1: FORTRAN Floating Point in a Nutshell: Philosophy

(module
  (type (;0;) (func (param f32 f32 f32 f32) (result f32)))
  (type (;1;) (func (param f64 f64 f64 f64) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (param $y f32) (param $z f32) (param $w f32) (result f32)
    i64.const 12
    i64.const 3
    call 1
    i64.const 8
    call 0
    local.get $x
    local.get $y
    f32.div
    local.get $z
    local.get $w
    f32.div
    f32.mul
  )
  (func (;3;) (type 1) (param $x f64) (param $y f64) (param $z f64) (param $w f64) (result f64)
    i64.const 24
    i64.const 3
    call 1
    i64.const 8
    call 0
    local.get $x
    local.get $y
    f64.div
    local.get $z
    local.get $w
    f64.div
    f64.mul
  )
  (export "f32.no_fold_mul_divs" (func 2))
  (export "f64.no_fold_mul_divs" (func 3))
)
(assert_return (invoke "f32.no_fold_mul_divs" (f32.const -0x1.c483bep-109) (f32.const 0x1.ee1c3cp-92) (f32.const 0x1.800756p-88) (f32.const -0x1.95b972p+4)) (f32.const 0x1.bbd30cp-110))
(assert_return (invoke "f32.no_fold_mul_divs" (f32.const -0x1.0f4262p+102) (f32.const 0x1.248498p+25) (f32.const 0x1.f66a7cp-17) (f32.const 0x1.897fc8p-3)) (f32.const -0x1.2f1aa4p+63))
(assert_return (invoke "f32.no_fold_mul_divs" (f32.const -0x1.df5f22p+33) (f32.const -0x1.fcee3ep+39) (f32.const -0x1.9ea914p+29) (f32.const -0x1.2c4d3p+10)) (f32.const 0x1.4cf51cp+13))
(assert_return (invoke "f32.no_fold_mul_divs" (f32.const -0x1.f568bcp+109) (f32.const 0x1.d9963p-34) (f32.const 0x1.37a87ap-16) (f32.const 0x1.a1524ap+78)) (f32.const -inf))
(assert_return (invoke "f32.no_fold_mul_divs" (f32.const 0x1.3dd592p-53) (f32.const -0x1.332c22p-64) (f32.const 0x1.b01064p-91) (f32.const 0x1.92bb3ap-36)) (f32.const -0x1.1c2dbp-44))

(assert_return (invoke "f64.no_fold_mul_divs" (f64.const -0x1.363d6764f7b12p-819) (f64.const -0x1.ed5471f660b5fp-464) (f64.const -0x1.671b0a7f3a42p+547) (f64.const 0x1.0633be34ba1f2p+186)) (f64.const -0x1.b8fa2b76baeebp+5))
(assert_return (invoke "f64.no_fold_mul_divs" (f64.const -0x1.37880182e0fa8p+115) (f64.const 0x1.f842631576147p-920) (f64.const -0x1.999372231d156p+362) (f64.const -0x1.d5db481ab9554p+467)) (f64.const -inf))
(assert_return (invoke "f64.no_fold_mul_divs" (f64.const -0x1.9a747c8d4b541p+308) (f64.const -0x1.99092ad6bbdc8p+192) (f64.const -0x1.cb23755c20101p-140) (f64.const -0x1.de8716f6b0b6ap+732)) (f64.const 0x1.ecf584c8466a5p-757))
(assert_return (invoke "f64.no_fold_mul_divs" (f64.const -0x1.c424b2ece903dp+129) (f64.const -0x1.568ce281db37fp-347) (f64.const 0x1.53900b99fd3dp-957) (f64.const 0x1.5c33952254dadp+223)) (f64.const 0x0p+0))
(assert_return (invoke "f64.no_fold_mul_divs" (f64.const 0x1.a8ec2cecb32a9p-18) (f64.const 0x1.58acab0051851p-277) (f64.const 0x1.35e87c9077f7fp-620) (f64.const -0x1.925ee37ffb386p+352)) (f64.const -0x1.e6286970b31bfp-714))

;; Test that (x/z)+(y/z) is not optimized to (x+y)/z.

(module
  (type (;0;) (func (param f32 f32 f32) (result f32)))
  (type (;1;) (func (param f64 f64 f64) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (param $y f32) (param $z f32) (result f32)
    i64.const 12
    i64.const 2
    call 1
    i64.const 8
    call 0
    local.get $x
    local.get $z
    f32.div
    local.get $y
    local.get $z
    f32.div
    f32.add
  )
  (func (;3;) (type 1) (param $x f64) (param $y f64) (param $z f64) (result f64)
    i64.const 24
    i64.const 2
    call 1
    i64.const 8
    call 0
    local.get $x
    local.get $z
    f64.div
    local.get $y
    local.get $z
    f64.div
    f64.add
  )
  (export "f32.no_fold_add_divs" (func 2))
  (export "f64.no_fold_add_divs" (func 3))
)
(assert_return (invoke "f32.no_fold_add_divs" (f32.const 0x1.795e7p+8) (f32.const -0x1.48a5eep-5) (f32.const -0x1.9a244cp+126)) (f32.const -0x1.d709b6p-119))
(assert_return (invoke "f32.no_fold_add_divs" (f32.const -0x1.ae89e8p-63) (f32.const -0x1.e9903ep-49) (f32.const -0x1.370a8cp+47)) (f32.const 0x1.92f3f6p-96))
(assert_return (invoke "f32.no_fold_add_divs" (f32.const -0x1.626408p-46) (f32.const 0x1.2ee5b2p-64) (f32.const -0x1.ecefaap+48)) (f32.const 0x1.701864p-95))
(assert_return (invoke "f32.no_fold_add_divs" (f32.const -0x1.061d3p-101) (f32.const 0x1.383492p-98) (f32.const -0x1.1d92d2p+88)) (f32.const 0x0p+0))
(assert_return (invoke "f32.no_fold_add_divs" (f32.const 0x1.1ea39ep-10) (f32.const 0x1.a7fffep-3) (f32.const 0x1.6fc574p-123)) (f32.const 0x1.28b2dep+120))

(assert_return (invoke "f64.no_fold_add_divs" (f64.const -0x1.c5fcc3273b136p+430) (f64.const 0x1.892a09eed8f6fp+434) (f64.const 0x1.8258b71e64397p+911)) (f64.const 0x1.e36eb9706ad82p-478))
(assert_return (invoke "f64.no_fold_add_divs" (f64.const -0x1.2215d4061b5b3p+53) (f64.const 0x1.fb6184d97f27cp+5) (f64.const -0x1.f3bb59dacc0ebp-957)) (f64.const 0x1.2934eb0118be3p+1009))
(assert_return (invoke "f64.no_fold_add_divs" (f64.const -0x1.e7a4533741d8ep-967) (f64.const 0x1.a519bb7feb802p-976) (f64.const 0x1.1f8a43454e51ap+504)) (f64.const 0x0p+0))
(assert_return (invoke "f64.no_fold_add_divs" (f64.const 0x1.991c6cf93e2b4p+313) (f64.const -0x1.f2f7432698d11p+329) (f64.const 0x1.0d8c1b2453617p-126)) (f64.const -0x1.d9e1d84ddd1d4p+455))
(assert_return (invoke "f64.no_fold_add_divs" (f64.const -0x1.d436849dc1271p-728) (f64.const 0x1.19d1c1450e52dp-755) (f64.const 0x1.fa1be69ea06fep-70)) (f64.const -0x1.d9a9b1c2f5623p-659))

;; Test that sqrt(x*x) is not optimized to abs(x).

(module
  (type (;0;) (func (param f32) (result f32)))
  (type (;1;) (func (param f64) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (result f32)
    i64.const 8
    i64.const 0
    call 1
    i64.const 5
    call 0
    local.get $x
    local.get $x
    f32.mul
    f32.sqrt
  )
  (func (;3;) (type 1) (param $x f64) (result f64)
    i64.const 16
    i64.const 0
    call 1
    i64.const 5
    call 0
    local.get $x
    local.get $x
    f64.mul
    f64.sqrt
  )
  (export "f32.no_fold_sqrt_square" (func 2))
  (export "f64.no_fold_sqrt_square" (func 3))
)
(assert_return (invoke "f32.no_fold_sqrt_square" (f32.const -0x1.5cb316p-66)) (f32.const 0x1.5cb322p-66))
(assert_return (invoke "f32.no_fold_sqrt_square" (f32.const -0x1.b0f9e4p-73)) (f32.const 0x1.b211b2p-73))
(assert_return (invoke "f32.no_fold_sqrt_square" (f32.const -0x1.de417cp-71)) (f32.const 0x1.de65b8p-71))
(assert_return (invoke "f32.no_fold_sqrt_square" (f32.const 0x1.64c872p-86)) (f32.const 0x0p+0))
(assert_return (invoke "f32.no_fold_sqrt_square" (f32.const 0x1.e199e4p+108)) (f32.const inf))

(assert_return (invoke "f64.no_fold_sqrt_square" (f64.const 0x1.1759d657203fdp-529)) (f64.const 0x1.1759dd57545f3p-529))
(assert_return (invoke "f64.no_fold_sqrt_square" (f64.const -0x1.4c68de1c78d83p-514)) (f64.const 0x1.4c68de1c78d81p-514))
(assert_return (invoke "f64.no_fold_sqrt_square" (f64.const -0x1.214736edb6e1ep-521)) (f64.const 0x1.214736ed9cf8dp-521))
(assert_return (invoke "f64.no_fold_sqrt_square" (f64.const -0x1.0864b9f68457p-616)) (f64.const 0x0p+0))
(assert_return (invoke "f64.no_fold_sqrt_square" (f64.const 0x1.b2a9855995abap+856)) (f64.const inf))

;; Test that sqrt(x)*sqrt(y) is not optimized to sqrt(x*y).

(module
  (type (;0;) (func (param f32 f32) (result f32)))
  (type (;1;) (func (param f64 f64) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (param $y f32) (result f32)
    i64.const 8
    i64.const 1
    call 1
    i64.const 6
    call 0
    local.get $x
    f32.sqrt
    local.get $y
    f32.sqrt
    f32.mul
  )
  (func (;3;) (type 1) (param $x f64) (param $y f64) (result f64)
    i64.const 16
    i64.const 1
    call 1
    i64.const 6
    call 0
    local.get $x
    f64.sqrt
    local.get $y
    f64.sqrt
    f64.mul
  )
  (export "f32.no_fold_mul_sqrts" (func 2))
  (export "f64.no_fold_mul_sqrts" (func 3))
)
(assert_return (invoke "f32.no_fold_mul_sqrts" (f32.const 0x1.dddda8p-125) (f32.const -0x1.25d22ap-83)) (f32.const nan:canonical))
(assert_return (invoke "f32.no_fold_mul_sqrts" (f32.const 0x1.418d14p-92) (f32.const 0x1.c6535cp-32)) (f32.const 0x1.7e373ap-62))
(assert_return (invoke "f32.no_fold_mul_sqrts" (f32.const 0x1.4de7ep-88) (f32.const 0x1.84ff18p+6)) (f32.const 0x1.686668p-41))
(assert_return (invoke "f32.no_fold_mul_sqrts" (f32.const 0x1.78091ep+101) (f32.const 0x1.81feb8p-9)) (f32.const 0x1.7cfb98p+46))
(assert_return (invoke "f32.no_fold_mul_sqrts" (f32.const 0x1.583ap-56) (f32.const 0x1.14ba2ap-9)) (f32.const 0x1.b47a8ep-33))

(assert_return (invoke "f64.no_fold_mul_sqrts" (f64.const -0x1.d1144cc28cdbep-635) (f64.const -0x1.bf9bc373d3b6ap-8)) (f64.const nan:canonical))
(assert_return (invoke "f64.no_fold_mul_sqrts" (f64.const 0x1.5a7eb976bebc9p-643) (f64.const 0x1.f30cb8865a4cap-404)) (f64.const 0x1.260a1032d6e76p-523))
(assert_return (invoke "f64.no_fold_mul_sqrts" (f64.const 0x1.711a0c1707935p-89) (f64.const 0x1.6fb5de51a20d3p-913)) (f64.const 0x1.7067ca28e31ecp-501))
(assert_return (invoke "f64.no_fold_mul_sqrts" (f64.const 0x1.fb0bbea33b076p-363) (f64.const 0x1.d963b34894158p-573)) (f64.const 0x1.e9edc1fa624afp-468))
(assert_return (invoke "f64.no_fold_mul_sqrts" (f64.const 0x1.8676eab7a4d0dp+24) (f64.const 0x1.75a58231ba7a5p+513)) (f64.const 0x1.0e16aebe203b3p+269))

;; Test that sqrt(x)/sqrt(y) is not optimized to sqrt(x/y).

(module
  (type (;0;) (func (param f32 f32) (result f32)))
  (type (;1;) (func (param f64 f64) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (param $y f32) (result f32)
    i64.const 8
    i64.const 1
    call 1
    i64.const 6
    call 0
    local.get $x
    f32.sqrt
    local.get $y
    f32.sqrt
    f32.div
  )
  (func (;3;) (type 1) (param $x f64) (param $y f64) (result f64)
    i64.const 16
    i64.const 1
    call 1
    i64.const 6
    call 0
    local.get $x
    f64.sqrt
    local.get $y
    f64.sqrt
    f64.div
  )
  (export "f32.no_fold_div_sqrts" (func 2))
  (export "f64.no_fold_div_sqrts" (func 3))
)
(assert_return (invoke "f32.no_fold_div_sqrts" (f32.const -0x1.bea9bap+25) (f32.const -0x1.db776ep-58)) (f32.const nan:canonical))
(assert_return (invoke "f32.no_fold_div_sqrts" (f32.const 0x1.b983b6p+32) (f32.const 0x1.901f1ep+27)) (f32.const 0x1.7c4df6p+2))
(assert_return (invoke "f32.no_fold_div_sqrts" (f32.const 0x1.d45e72p-120) (f32.const 0x1.ab49ccp+15)) (f32.const 0x1.7b0b04p-68))
(assert_return (invoke "f32.no_fold_div_sqrts" (f32.const 0x1.b2e444p+59) (f32.const 0x1.5b8b16p-30)) (f32.const 0x1.94fca8p+44))
(assert_return (invoke "f32.no_fold_div_sqrts" (f32.const 0x1.835aa6p-112) (f32.const 0x1.d17128p-103)) (f32.const 0x1.4a468p-5))

(assert_return (invoke "f64.no_fold_div_sqrts" (f64.const -0x1.509fc16411167p-711) (f64.const -0x1.9c4255f5d6517p-187)) (f64.const nan:canonical))
(assert_return (invoke "f64.no_fold_div_sqrts" (f64.const 0x1.b6897bddac76p-587) (f64.const 0x1.104578b4c91f3p+541)) (f64.const 0x1.44e4f21f26cc9p-564))
(assert_return (invoke "f64.no_fold_div_sqrts" (f64.const 0x1.ac83451b08989p+523) (f64.const 0x1.8da575c6d12b8p-109)) (f64.const 0x1.09c003991ce17p+316))
(assert_return (invoke "f64.no_fold_div_sqrts" (f64.const 0x1.bab7836456417p-810) (f64.const 0x1.1ff60d03ba607p+291)) (f64.const 0x1.c0e6c833bf657p-551))
(assert_return (invoke "f64.no_fold_div_sqrts" (f64.const 0x1.a957816ad9515p-789) (f64.const 0x1.8c18a3a222ab1p+945)) (f64.const 0x1.0948539781e92p-867))

;; Test that (x*sqrt(y))/y is not optimized to x/sqrt(y).

(module
  (type (;0;) (func (param f32 f32) (result f32)))
  (type (;1;) (func (param f64 f64) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (param $y f32) (result f32)
    i64.const 8
    i64.const 1
    call 1
    i64.const 7
    call 0
    local.get $x
    local.get $y
    f32.sqrt
    f32.mul
    local.get $y
    f32.div
  )
  (func (;3;) (type 1) (param $x f64) (param $y f64) (result f64)
    i64.const 16
    i64.const 1
    call 1
    i64.const 7
    call 0
    local.get $x
    local.get $y
    f64.sqrt
    f64.mul
    local.get $y
    f64.div
  )
  (export "f32.no_fold_mul_sqrt_div" (func 2))
  (export "f64.no_fold_mul_sqrt_div" (func 3))
)
(assert_return (invoke "f32.no_fold_mul_sqrt_div" (f32.const -0x1.f4a7cap+81) (f32.const 0x1.c09adep+92)) (f32.const -inf))
(assert_return (invoke "f32.no_fold_mul_sqrt_div" (f32.const -0x1.90bf1cp-120) (f32.const 0x1.8dbe88p-97)) (f32.const -0x0p+0))
(assert_return (invoke "f32.no_fold_mul_sqrt_div" (f32.const 0x1.8570e8p+29) (f32.const 0x1.217d3p-128)) (f32.const 0x1.6e391ap+93))
(assert_return (invoke "f32.no_fold_mul_sqrt_div" (f32.const -0x1.5b4652p+43) (f32.const 0x1.a9d71cp+112)) (f32.const -0x1.0d423ap-13))
(assert_return (invoke "f32.no_fold_mul_sqrt_div" (f32.const -0x1.910604p+8) (f32.const 0x1.0ca912p+7)) (f32.const -0x1.14cdecp+5))

(assert_return (invoke "f64.no_fold_mul_sqrt_div" (f64.const 0x1.1dcdeb857305fp+698) (f64.const 0x1.a066171c40eb9p+758)) (f64.const inf))
(assert_return (invoke "f64.no_fold_mul_sqrt_div" (f64.const -0x1.8b4f1c218e2abp-827) (f64.const 0x1.5e1ee65953b0bp-669)) (f64.const -0x0p+0))
(assert_return (invoke "f64.no_fold_mul_sqrt_div" (f64.const 0x1.74ee531ddba38p-425) (f64.const 0x1.f370f758857f3p+560)) (f64.const 0x1.0aff34269583ep-705))
(assert_return (invoke "f64.no_fold_mul_sqrt_div" (f64.const -0x1.27f216b0da6c5p+352) (f64.const 0x1.8e0b4e0b9fd7ep-483)) (f64.const -0x1.4fa558aad514ep+593))
(assert_return (invoke "f64.no_fold_mul_sqrt_div" (f64.const 0x1.4c6955df9912bp+104) (f64.const 0x1.0cca42c9d371ep+842)) (f64.const 0x1.4468072f54294p-317))

;; Test that subnormals are not flushed even in an intermediate value in an
;; expression with a normal result.

(module
  (type (;0;) (func (param f32 f32 f32) (result f32)))
  (type (;1;) (func (param f64 f64 f64) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (param $y f32) (param $z f32) (result f32)
    i64.const 8
    i64.const 2
    call 1
    i64.const 6
    call 0
    local.get $x
    local.get $y
    f32.mul
    local.get $z
    f32.mul
  )
  (func (;3;) (type 1) (param $x f64) (param $y f64) (param $z f64) (result f64)
    i64.const 16
    i64.const 2
    call 1
    i64.const 6
    call 0
    local.get $x
    local.get $y
    f64.mul
    local.get $z
    f64.mul
  )
  (export "f32.no_flush_intermediate_subnormal" (func 2))
  (export "f64.no_flush_intermediate_subnormal" (func 3))
)
(assert_return (invoke "f32.no_flush_intermediate_subnormal" (f32.const 0x1p-126) (f32.const 0x1p-23) (f32.const 0x1p23)) (f32.const 0x1p-126))
(assert_return (invoke "f64.no_flush_intermediate_subnormal" (f64.const 0x1p-1022) (f64.const 0x1p-52) (f64.const 0x1p52)) (f64.const 0x1p-1022))

;; Test corner cases of John Hauser's microarchitectural recoding scheme.
;; https://github.com/riscv/riscv-tests/blob/695b86a6fcbe06ffbed8891af7e6fe7bf2062543/isa/rv64uf/recoding.S

(module
  (type (;0;) (func (param f32 f32) (result i32)))
  (type (;1;) (func (param f64 f64) (result i32)))
  (type (;2;) (func (param f64 f32) (result f32)))
  (type (;3;) (func (param i64)))
  (type (;4;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 3)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 4)))
  (func (;2;) (type 0) (param $x f32) (param $y f32) (result i32)
    i64.const 8
    i64.const 1
    call 1
    i64.const 6
    call 0
    local.get $x
    local.get $y
    f32.mul
    local.get $x
    f32.eq
  )
  (func (;3;) (type 0) (param $x f32) (param $y f32) (result i32)
    i64.const 8
    i64.const 1
    call 1
    i64.const 6
    call 0
    local.get $x
    local.get $y
    f32.mul
    local.get $x
    f32.le
  )
  (func (;4;) (type 0) (param $x f32) (param $y f32) (result i32)
    i64.const 8
    i64.const 1
    call 1
    i64.const 6
    call 0
    local.get $x
    local.get $y
    f32.mul
    local.get $x
    f32.lt
  )
  (func (;5;) (type 1) (param $x f64) (param $y f64) (result i32)
    i64.const 16
    i64.const 1
    call 1
    i64.const 6
    call 0
    local.get $x
    local.get $y
    f64.mul
    local.get $x
    f64.eq
  )
  (func (;6;) (type 1) (param $x f64) (param $y f64) (result i32)
    i64.const 16
    i64.const 1
    call 1
    i64.const 6
    call 0
    local.get $x
    local.get $y
    f64.mul
    local.get $x
    f64.le
  )
  (func (;7;) (type 1) (param $x f64) (param $y f64) (result i32)
    i64.const 16
    i64.const 1
    call 1
    i64.const 6
    call 0
    local.get $x
    local.get $y
    f64.mul
    local.get $x
    f64.lt
  )
  (func (;8;) (type 2) (param $x f64) (param $y f32) (result f32)
    i64.const 8
    i64.const 1
    call 1
    i64.const 5
    call 0
    local.get $x
    f32.demote_f64
    local.get $y
    f32.mul
  )
  (export "f32.recoding_eq" (func 2))
  (export "f32.recoding_le" (func 3))
  (export "f32.recoding_lt" (func 4))
  (export "f64.recoding_eq" (func 5))
  (export "f64.recoding_le" (func 6))
  (export "f64.recoding_lt" (func 7))
  (export "recoding_demote" (func 8))
)
(assert_return (invoke "f32.recoding_eq" (f32.const -inf) (f32.const 3.0)) (i32.const 1))
(assert_return (invoke "f32.recoding_le" (f32.const -inf) (f32.const 3.0)) (i32.const 1))
(assert_return (invoke "f32.recoding_lt" (f32.const -inf) (f32.const 3.0)) (i32.const 0))

(assert_return (invoke "f32.recoding_eq" (f32.const 0x0p+0) (f32.const 0x1p+0)) (i32.const 1))
(assert_return (invoke "f32.recoding_le" (f32.const 0x0p+0) (f32.const 0x1p+0)) (i32.const 1))
(assert_return (invoke "f32.recoding_lt" (f32.const 0x0p+0) (f32.const 0x1p+0)) (i32.const 0))

(assert_return (invoke "f64.recoding_eq" (f64.const -inf) (f64.const 3.0)) (i32.const 1))
(assert_return (invoke "f64.recoding_le" (f64.const -inf) (f64.const 3.0)) (i32.const 1))
(assert_return (invoke "f64.recoding_lt" (f64.const -inf) (f64.const 3.0)) (i32.const 0))

(assert_return (invoke "f64.recoding_eq" (f64.const 0x0p+0) (f64.const 0x1p+0)) (i32.const 1))
(assert_return (invoke "f64.recoding_le" (f64.const 0x0p+0) (f64.const 0x1p+0)) (i32.const 1))
(assert_return (invoke "f64.recoding_lt" (f64.const 0x0p+0) (f64.const 0x1p+0)) (i32.const 0))

(assert_return (invoke "recoding_demote" (f64.const 0x1.4c8f8p-132) (f32.const 1221)) (f32.const 0x1.8c8a1cp-122))

;; Test that division is not done as on an extended-base system.
;; http://www.ucbtest.org/goldberg/addendum.html

(module
  (type (;0;) (func (param f32 f32 f32) (result i32)))
  (type (;1;) (func (param f64 f64 f64) (result i32)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (param $y f32) (param $z f32) (result i32)
    i64.const 8
    i64.const 2
    call 1
    i64.const 6
    call 0
    local.get $x
    local.get $y
    f32.div
    local.get $z
    f32.eq
  )
  (func (;3;) (type 1) (param $x f64) (param $y f64) (param $z f64) (result i32)
    i64.const 16
    i64.const 2
    call 1
    i64.const 6
    call 0
    local.get $x
    local.get $y
    f64.div
    local.get $z
    f64.eq
  )
  (export "f32.no_extended_precision_div" (func 2))
  (export "f64.no_extended_precision_div" (func 3))
)
(assert_return (invoke "f32.no_extended_precision_div" (f32.const 3.0) (f32.const 7.0) (f32.const 0x1.b6db6ep-2)) (i32.const 1))
(assert_return (invoke "f64.no_extended_precision_div" (f64.const 3.0) (f64.const 7.0) (f64.const 0x1.b6db6db6db6dbp-2)) (i32.const 1))

;; a*x + b*x == (a+b)*x for all x only if the operations a*x, b*x, and (a+b)
;; are all exact operations, which is true only if a and b are exact powers of
;; 2. Even then, if a==-b and x==-0, then a*x+b*x==0.0, (a+b)*x==-0.0.
;; https://dlang.org/d-floating-point.html

(module
  (type (;0;) (func (param f32) (result f32)))
  (type (;1;) (func (param f64) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (result f32)
    i64.const 12
    i64.const 0
    call 1
    i64.const 8
    call 0
    f32.const -0x1p+3 (;=-8;)
    local.get $x
    f32.mul
    f32.const 0x1p+3 (;=8;)
    local.get $x
    f32.mul
    f32.add
  )
  (func (;3;) (type 1) (param $x f64) (result f64)
    i64.const 24
    i64.const 0
    call 1
    i64.const 8
    call 0
    f64.const -0x1p+3 (;=-8;)
    local.get $x
    f64.mul
    f64.const 0x1p+3 (;=8;)
    local.get $x
    f64.mul
    f64.add
  )
  (export "f32.no_distribute_exact" (func 2))
  (export "f64.no_distribute_exact" (func 3))
)
(assert_return (invoke "f32.no_distribute_exact" (f32.const -0.0)) (f32.const 0.0))
(assert_return (invoke "f64.no_distribute_exact" (f64.const -0.0)) (f64.const 0.0))

;; Test that various approximations of sqrt(2), sqrt(3), and sqrt(5) compute the
;; expected approximation.
;; https://xkcd.com/1047/
(module
  (type (;0;) (func (param f32) (result f32)))
  (type (;1;) (func (param f32 f32 f32 f32) (result f32)))
  (type (;2;) (func (param f32 f32 f32) (result f32)))
  (type (;3;) (func (param f64) (result f64)))
  (type (;4;) (func (param f64 f64 f64 f64) (result f64)))
  (type (;5;) (func (param f64 f64 f64) (result f64)))
  (type (;6;) (func (param i64)))
  (type (;7;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 6)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 7)))
  (func (;2;) (type 0) (param f32) (result f32)
    i64.const 4
    i64.const 0
    call 1
    i64.const 3
    call 0
    local.get 0
    f32.sqrt
  )
  (func (;3;) (type 1) (param f32 f32 f32 f32) (result f32)
    i64.const 16
    i64.const 3
    call 1
    i64.const 10
    call 0
    local.get 0
    local.get 1
    f32.div
    local.get 2
    local.get 3
    local.get 2
    f32.sub
    f32.div
    f32.add
  )
  (func (;4;) (type 2) (param f32 f32 f32) (result f32)
    i64.const 8
    i64.const 2
    call 1
    i64.const 6
    call 0
    local.get 0
    local.get 1
    f32.mul
    local.get 2
    f32.div
  )
  (func (;5;) (type 2) (param f32 f32 f32) (result f32)
    i64.const 12
    i64.const 2
    call 1
    i64.const 8
    call 0
    local.get 0
    local.get 1
    f32.div
    local.get 2
    local.get 0
    f32.div
    f32.add
  )
  (func (;6;) (type 1) (param f32 f32 f32 f32) (result f32)
    i64.const 16
    i64.const 3
    call 1
    i64.const 12
    call 0
    local.get 0
    local.get 1
    local.get 2
    f32.mul
    f32.add
    local.get 3
    local.get 1
    local.get 2
    f32.mul
    f32.sub
    f32.div
  )
  (func (;7;) (type 3) (param f64) (result f64)
    i64.const 8
    i64.const 0
    call 1
    i64.const 3
    call 0
    local.get 0
    f64.sqrt
  )
  (func (;8;) (type 4) (param f64 f64 f64 f64) (result f64)
    i64.const 32
    i64.const 3
    call 1
    i64.const 10
    call 0
    local.get 0
    local.get 1
    f64.div
    local.get 2
    local.get 3
    local.get 2
    f64.sub
    f64.div
    f64.add
  )
  (func (;9;) (type 5) (param f64 f64 f64) (result f64)
    i64.const 16
    i64.const 2
    call 1
    i64.const 6
    call 0
    local.get 0
    local.get 1
    f64.mul
    local.get 2
    f64.div
  )
  (func (;10;) (type 5) (param f64 f64 f64) (result f64)
    i64.const 24
    i64.const 2
    call 1
    i64.const 8
    call 0
    local.get 0
    local.get 1
    f64.div
    local.get 2
    local.get 0
    f64.div
    f64.add
  )
  (func (;11;) (type 4) (param f64 f64 f64 f64) (result f64)
    i64.const 32
    i64.const 3
    call 1
    i64.const 12
    call 0
    local.get 0
    local.get 1
    local.get 2
    f64.mul
    f64.add
    local.get 3
    local.get 1
    local.get 2
    f64.mul
    f64.sub
    f64.div
  )
  (export "f32.sqrt" (func 2))
  (export "f32.xkcd_sqrt_2" (func 3))
  (export "f32.xkcd_sqrt_3" (func 4))
  (export "f32.xkcd_sqrt_5" (func 5))
  (export "f32.xkcd_better_sqrt_5" (func 6))
  (export "f64.sqrt" (func 7))
  (export "f64.xkcd_sqrt_2" (func 8))
  (export "f64.xkcd_sqrt_3" (func 9))
  (export "f64.xkcd_sqrt_5" (func 10))
  (export "f64.xkcd_better_sqrt_5" (func 11))
)
(assert_return (invoke "f32.sqrt" (f32.const 2.0)) (f32.const 0x1.6a09e6p+0))
(assert_return (invoke "f32.xkcd_sqrt_2" (f32.const 3.0) (f32.const 5.0) (f32.const 0x1.921fb6p+1) (f32.const 7.0)) (f32.const 0x1.6a0a54p+0))
(assert_return (invoke "f32.sqrt" (f32.const 3.0)) (f32.const 0x1.bb67aep+0))
(assert_return (invoke "f32.xkcd_sqrt_3" (f32.const 2.0) (f32.const 0x1.5bf0a8p+1) (f32.const 0x1.921fb6p+1)) (f32.const 0x1.bb02d4p+0))
(assert_return (invoke "f32.sqrt" (f32.const 5.0)) (f32.const 0x1.1e377ap+1))
(assert_return (invoke "f32.xkcd_sqrt_5" (f32.const 2.0) (f32.const 0x1.5bf0a8p+1) (f32.const 3.0)) (f32.const 0x1.1e2d58p+1))
(assert_return (invoke "f32.xkcd_better_sqrt_5" (f32.const 13.0) (f32.const 4.0) (f32.const 0x1.921fb6p+1) (f32.const 24.0)) (f32.const 0x1.1e377ap+1))

(assert_return (invoke "f64.sqrt" (f64.const 2.0)) (f64.const 0x1.6a09e667f3bcdp+0))
(assert_return (invoke "f64.xkcd_sqrt_2" (f64.const 3.0) (f64.const 5.0) (f64.const 0x1.921fb54442d18p+1) (f64.const 7.0)) (f64.const 0x1.6a0a5362b055fp+0))
(assert_return (invoke "f64.sqrt" (f64.const 3.0)) (f64.const 0x1.bb67ae8584caap+0))
(assert_return (invoke "f64.xkcd_sqrt_3" (f64.const 2.0) (f64.const 0x1.5bf0a8b145769p+1) (f64.const 0x1.921fb54442d18p+1)) (f64.const 0x1.bb02d4eca8f95p+0))
(assert_return (invoke "f64.sqrt" (f64.const 5.0)) (f64.const 0x1.1e3779b97f4a8p+1))
(assert_return (invoke "f64.xkcd_sqrt_5" (f64.const 2.0) (f64.const 0x1.5bf0a8b145769p+1) (f64.const 3.0)) (f64.const 0x1.1e2d58d8b3bcep+1))
(assert_return (invoke "f64.xkcd_better_sqrt_5" (f64.const 13.0) (f64.const 4.0) (f64.const 0x1.921fb54442d18p+1) (f64.const 24.0)) (f64.const 0x1.1e3778509a5a3p+1))

;; Compute the floating-point radix.
;; M. A. Malcom. Algorithms to reveal properties of floating-point arithmetic.
;; Communications of the ACM, 15(11):949-951, November 1972.
(module
  (type (;0;) (func (param f32 f32) (result f32)))
  (type (;1;) (func (param f64 f64) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $0 f32) (param $1 f32) (result f32)
    i64.const 12
    i64.const 1
    call 1
    i64.const 1
    call 0
    loop $label$0 ;; label = @1
      i64.const 13
      call 0
      local.get $0
      local.get $0
      f32.add
      local.tee $0
      f32.const 0x1p+0 (;=1;)
      f32.add
      local.get $0
      f32.sub
      f32.const -0x1p+0 (;=-1;)
      f32.add
      f32.const 0x0p+0 (;=0;)
      f32.eq
      br_if 0 (;@1;)
      i64.const 2
      call 0
    end
    loop $label$2 ;; label = @1
      i64.const 13
      call 0
      local.get $0
      local.get $1
      f32.const 0x1p+0 (;=1;)
      f32.add
      local.tee $1
      f32.add
      local.get $0
      f32.sub
      local.get $1
      f32.sub
      f32.const 0x0p+0 (;=0;)
      f32.ne
      br_if 0 (;@1;)
      i64.const 3
      call 0
    end
    local.get $1
  )
  (func (;3;) (type 1) (param $0 f64) (param $1 f64) (result f64)
    i64.const 24
    i64.const 1
    call 1
    i64.const 1
    call 0
    loop $label$0 ;; label = @1
      i64.const 13
      call 0
      local.get $0
      local.get $0
      f64.add
      local.tee $0
      f64.const 0x1p+0 (;=1;)
      f64.add
      local.get $0
      f64.sub
      f64.const -0x1p+0 (;=-1;)
      f64.add
      f64.const 0x0p+0 (;=0;)
      f64.eq
      br_if 0 (;@1;)
      i64.const 2
      call 0
    end
    loop $label$2 ;; label = @1
      i64.const 13
      call 0
      local.get $0
      local.get $1
      f64.const 0x1p+0 (;=1;)
      f64.add
      local.tee $1
      f64.add
      local.get $0
      f64.sub
      local.get $1
      f64.sub
      f64.const 0x0p+0 (;=0;)
      f64.ne
      br_if 0 (;@1;)
      i64.const 3
      call 0
    end
    local.get $1
  )
  (export "f32.compute_radix" (func 2))
  (export "f64.compute_radix" (func 3))
)
(assert_return (invoke "f32.compute_radix" (f32.const 1.0) (f32.const 1.0)) (f32.const 2.0))
(assert_return (invoke "f64.compute_radix" (f64.const 1.0) (f64.const 1.0)) (f64.const 2.0))

;; Test that (x - 1) * y + y is not optimized to x * y.
;; http://blog.frama-c.com/index.php?post/2013/05/14/Contrarianism

(module
  (type (;0;) (func (param f32 f32) (result f32)))
  (type (;1;) (func (param f64 f64) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (param $y f32) (result f32)
    i64.const 8
    i64.const 1
    call 1
    i64.const 8
    call 0
    local.get $x
    f32.const 0x1p+0 (;=1;)
    f32.sub
    local.get $y
    f32.mul
    local.get $y
    f32.add
  )
  (func (;3;) (type 1) (param $x f64) (param $y f64) (result f64)
    i64.const 16
    i64.const 1
    call 1
    i64.const 8
    call 0
    local.get $x
    f64.const 0x1p+0 (;=1;)
    f64.sub
    local.get $y
    f64.mul
    local.get $y
    f64.add
  )
  (export "f32.no_fold_sub1_mul_add" (func 2))
  (export "f64.no_fold_sub1_mul_add" (func 3))
)
(assert_return (invoke "f32.no_fold_sub1_mul_add" (f32.const 0x1p-32) (f32.const 1.0)) (f32.const 0x0p+0))
(assert_return (invoke "f64.no_fold_sub1_mul_add" (f64.const 0x1p-64) (f64.const 1.0)) (f64.const 0x0p+0))

;; Test that x+z >= y+z is not optimized to x >= y (monotonicity).
;; http://cs.nyu.edu/courses/spring13/CSCI-UA.0201-003/lecture6.pdf

(module
  (type (;0;) (func (param f32 f32 f32) (result i32)))
  (type (;1;) (func (param f64 f64 f64) (result i32)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (param $y f32) (param $z f32) (result i32)
    i64.const 12
    i64.const 2
    call 1
    i64.const 8
    call 0
    local.get $x
    local.get $z
    f32.add
    local.get $y
    local.get $z
    f32.add
    f32.le
  )
  (func (;3;) (type 0) (param $x f32) (param $y f32) (param $z f32) (result i32)
    i64.const 12
    i64.const 2
    call 1
    i64.const 8
    call 0
    local.get $x
    local.get $z
    f32.add
    local.get $y
    local.get $z
    f32.add
    f32.ge
  )
  (func (;4;) (type 1) (param $x f64) (param $y f64) (param $z f64) (result i32)
    i64.const 24
    i64.const 2
    call 1
    i64.const 8
    call 0
    local.get $x
    local.get $z
    f64.add
    local.get $y
    local.get $z
    f64.add
    f64.le
  )
  (func (;5;) (type 1) (param $x f64) (param $y f64) (param $z f64) (result i32)
    i64.const 24
    i64.const 2
    call 1
    i64.const 8
    call 0
    local.get $x
    local.get $z
    f64.add
    local.get $y
    local.get $z
    f64.add
    f64.ge
  )
  (export "f32.no_fold_add_le_monotonicity" (func 2))
  (export "f32.no_fold_add_ge_monotonicity" (func 3))
  (export "f64.no_fold_add_le_monotonicity" (func 4))
  (export "f64.no_fold_add_ge_monotonicity" (func 5))
)
(assert_return (invoke "f32.no_fold_add_le_monotonicity" (f32.const 0.0) (f32.const 0.0) (f32.const nan)) (i32.const 0))
(assert_return (invoke "f32.no_fold_add_le_monotonicity" (f32.const inf) (f32.const -inf) (f32.const inf)) (i32.const 0))
(assert_return (invoke "f64.no_fold_add_le_monotonicity" (f64.const 0.0) (f64.const 0.0) (f64.const nan)) (i32.const 0))
(assert_return (invoke "f64.no_fold_add_le_monotonicity" (f64.const inf) (f64.const -inf) (f64.const inf)) (i32.const 0))

;; Test that !(x < y) and friends are not optimized to x >= y and friends.

(module
  (type (;0;) (func (param f32 f32) (result i32)))
  (type (;1;) (func (param f64 f64) (result i32)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (param $y f32) (result i32)
    i64.const 8
    i64.const 1
    call 1
    i64.const 5
    call 0
    local.get $x
    local.get $y
    f32.lt
    i32.eqz
  )
  (func (;3;) (type 0) (param $x f32) (param $y f32) (result i32)
    i64.const 8
    i64.const 1
    call 1
    i64.const 5
    call 0
    local.get $x
    local.get $y
    f32.le
    i32.eqz
  )
  (func (;4;) (type 0) (param $x f32) (param $y f32) (result i32)
    i64.const 8
    i64.const 1
    call 1
    i64.const 5
    call 0
    local.get $x
    local.get $y
    f32.gt
    i32.eqz
  )
  (func (;5;) (type 0) (param $x f32) (param $y f32) (result i32)
    i64.const 8
    i64.const 1
    call 1
    i64.const 5
    call 0
    local.get $x
    local.get $y
    f32.ge
    i32.eqz
  )
  (func (;6;) (type 1) (param $x f64) (param $y f64) (result i32)
    i64.const 16
    i64.const 1
    call 1
    i64.const 5
    call 0
    local.get $x
    local.get $y
    f64.lt
    i32.eqz
  )
  (func (;7;) (type 1) (param $x f64) (param $y f64) (result i32)
    i64.const 16
    i64.const 1
    call 1
    i64.const 5
    call 0
    local.get $x
    local.get $y
    f64.le
    i32.eqz
  )
  (func (;8;) (type 1) (param $x f64) (param $y f64) (result i32)
    i64.const 16
    i64.const 1
    call 1
    i64.const 5
    call 0
    local.get $x
    local.get $y
    f64.gt
    i32.eqz
  )
  (func (;9;) (type 1) (param $x f64) (param $y f64) (result i32)
    i64.const 16
    i64.const 1
    call 1
    i64.const 5
    call 0
    local.get $x
    local.get $y
    f64.ge
    i32.eqz
  )
  (export "f32.not_lt" (func 2))
  (export "f32.not_le" (func 3))
  (export "f32.not_gt" (func 4))
  (export "f32.not_ge" (func 5))
  (export "f64.not_lt" (func 6))
  (export "f64.not_le" (func 7))
  (export "f64.not_gt" (func 8))
  (export "f64.not_ge" (func 9))
)
(assert_return (invoke "f32.not_lt" (f32.const nan) (f32.const 0.0)) (i32.const 1))
(assert_return (invoke "f32.not_le" (f32.const nan) (f32.const 0.0)) (i32.const 1))
(assert_return (invoke "f32.not_gt" (f32.const nan) (f32.const 0.0)) (i32.const 1))
(assert_return (invoke "f32.not_ge" (f32.const nan) (f32.const 0.0)) (i32.const 1))
(assert_return (invoke "f64.not_lt" (f64.const nan) (f64.const 0.0)) (i32.const 1))
(assert_return (invoke "f64.not_le" (f64.const nan) (f64.const 0.0)) (i32.const 1))
(assert_return (invoke "f64.not_gt" (f64.const nan) (f64.const 0.0)) (i32.const 1))
(assert_return (invoke "f64.not_ge" (f64.const nan) (f64.const 0.0)) (i32.const 1))

;; Test that a method for approximating a "machine epsilon" produces the expected
;; approximation.
;; http://blogs.mathworks.com/cleve/2014/07/07/floating-point-numbers/#24cb4f4d-b8a9-4c19-b22b-9d2a9f7f3812

(module
  (type (;0;) (func (result f32)))
  (type (;1;) (func (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (result f32)
    i64.const 16
    i64.const 0
    call 1
    i64.const 10
    call 0
    f32.const 0x1p+0 (;=1;)
    f32.const 0x1.8p+1 (;=3;)
    f32.const 0x1p+2 (;=4;)
    f32.const 0x1.8p+1 (;=3;)
    f32.div
    f32.const 0x1p+0 (;=1;)
    f32.sub
    f32.mul
    f32.sub
  )
  (func (;3;) (type 1) (result f64)
    i64.const 32
    i64.const 0
    call 1
    i64.const 10
    call 0
    f64.const 0x1p+0 (;=1;)
    f64.const 0x1.8p+1 (;=3;)
    f64.const 0x1p+2 (;=4;)
    f64.const 0x1.8p+1 (;=3;)
    f64.div
    f64.const 0x1p+0 (;=1;)
    f64.sub
    f64.mul
    f64.sub
  )
  (export "f32.epsilon" (func 2))
  (export "f64.epsilon" (func 3))
)
(assert_return (invoke "f32.epsilon") (f32.const -0x1p-23))
(assert_return (invoke "f64.epsilon") (f64.const 0x1p-52))

;; Test that a method for computing a "machine epsilon" produces the expected
;; result.
;; https://www.math.utah.edu/~beebe/software/ieee/

(module
  (type (;0;) (func (result f32)))
  (type (;1;) (func (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (result f32)
    (local $x f32) (local $result f32)
    i64.const 8
    i64.const 1
    call 1
    i64.const 3
    call 0
    f32.const 0x1p+0 (;=1;)
    local.set $x
    loop $loop ;; label = @1
      i64.const 10
      call 0
      local.get $x
      local.tee $result
      f32.const 0x1p-1 (;=0.5;)
      f32.mul
      local.tee $x
      f32.const 0x1p+0 (;=1;)
      f32.add
      f32.const 0x1p+0 (;=1;)
      f32.gt
      br_if 0 (;@1;)
      i64.const 3
      call 0
    end
    local.get $result
  )
  (func (;3;) (type 1) (result f64)
    (local $x f64) (local $result f64)
    i64.const 16
    i64.const 1
    call 1
    i64.const 3
    call 0
    f64.const 0x1p+0 (;=1;)
    local.set $x
    loop $loop ;; label = @1
      i64.const 10
      call 0
      local.get $x
      local.tee $result
      f64.const 0x1p-1 (;=0.5;)
      f64.mul
      local.tee $x
      f64.const 0x1p+0 (;=1;)
      f64.add
      f64.const 0x1p+0 (;=1;)
      f64.gt
      br_if 0 (;@1;)
      i64.const 3
      call 0
    end
    local.get $result
  )
  (export "f32.epsilon" (func 2))
  (export "f64.epsilon" (func 3))
)
(assert_return (invoke "f32.epsilon") (f32.const 0x1p-23))
(assert_return (invoke "f64.epsilon") (f64.const 0x1p-52))

;; Test that floating-point numbers are not optimized as if they form a
;; trichotomy.

(module
  (type (;0;) (func (param f32 f32) (result i32)))
  (type (;1;) (func (param f64 f64) (result i32)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (param $y f32) (result i32)
    i64.const 12
    i64.const 1
    call 1
    i64.const 8
    call 0
    local.get $x
    local.get $y
    f32.lt
    local.get $x
    local.get $y
    f32.ge
    i32.or
  )
  (func (;3;) (type 0) (param $x f32) (param $y f32) (result i32)
    i64.const 12
    i64.const 1
    call 1
    i64.const 8
    call 0
    local.get $x
    local.get $y
    f32.le
    local.get $x
    local.get $y
    f32.gt
    i32.or
  )
  (func (;4;) (type 0) (param $x f32) (param $y f32) (result i32)
    i64.const 12
    i64.const 1
    call 1
    i64.const 8
    call 0
    local.get $x
    local.get $y
    f32.gt
    local.get $x
    local.get $y
    f32.le
    i32.or
  )
  (func (;5;) (type 0) (param $x f32) (param $y f32) (result i32)
    i64.const 12
    i64.const 1
    call 1
    i64.const 8
    call 0
    local.get $x
    local.get $y
    f32.ge
    local.get $x
    local.get $y
    f32.lt
    i32.or
  )
  (func (;6;) (type 1) (param $x f64) (param $y f64) (result i32)
    i64.const 20
    i64.const 1
    call 1
    i64.const 8
    call 0
    local.get $x
    local.get $y
    f64.lt
    local.get $x
    local.get $y
    f64.ge
    i32.or
  )
  (func (;7;) (type 1) (param $x f64) (param $y f64) (result i32)
    i64.const 20
    i64.const 1
    call 1
    i64.const 8
    call 0
    local.get $x
    local.get $y
    f64.le
    local.get $x
    local.get $y
    f64.gt
    i32.or
  )
  (func (;8;) (type 1) (param $x f64) (param $y f64) (result i32)
    i64.const 20
    i64.const 1
    call 1
    i64.const 8
    call 0
    local.get $x
    local.get $y
    f64.gt
    local.get $x
    local.get $y
    f64.le
    i32.or
  )
  (func (;9;) (type 1) (param $x f64) (param $y f64) (result i32)
    i64.const 20
    i64.const 1
    call 1
    i64.const 8
    call 0
    local.get $x
    local.get $y
    f64.ge
    local.get $x
    local.get $y
    f64.lt
    i32.or
  )
  (export "f32.no_trichotomy_lt" (func 2))
  (export "f32.no_trichotomy_le" (func 3))
  (export "f32.no_trichotomy_gt" (func 4))
  (export "f32.no_trichotomy_ge" (func 5))
  (export "f64.no_trichotomy_lt" (func 6))
  (export "f64.no_trichotomy_le" (func 7))
  (export "f64.no_trichotomy_gt" (func 8))
  (export "f64.no_trichotomy_ge" (func 9))
)
(assert_return (invoke "f32.no_trichotomy_lt" (f32.const 0.0) (f32.const nan)) (i32.const 0))
(assert_return (invoke "f32.no_trichotomy_le" (f32.const 0.0) (f32.const nan)) (i32.const 0))
(assert_return (invoke "f32.no_trichotomy_gt" (f32.const 0.0) (f32.const nan)) (i32.const 0))
(assert_return (invoke "f32.no_trichotomy_ge" (f32.const 0.0) (f32.const nan)) (i32.const 0))
(assert_return (invoke "f64.no_trichotomy_lt" (f64.const 0.0) (f64.const nan)) (i32.const 0))
(assert_return (invoke "f64.no_trichotomy_le" (f64.const 0.0) (f64.const nan)) (i32.const 0))
(assert_return (invoke "f64.no_trichotomy_gt" (f64.const 0.0) (f64.const nan)) (i32.const 0))
(assert_return (invoke "f64.no_trichotomy_ge" (f64.const 0.0) (f64.const nan)) (i32.const 0))

;; Some test harnesses which can run this testsuite are unable to perform tests
;; of NaN bitpatterns. The following tests whether the underlying platform is
;; generally producing the kinds of NaNs expected.
(module
  (type (;0;) (func (param i32 i32) (result i32)))
  (type (;1;) (func (param i32) (result i32)))
  (type (;2;) (func (param i64 i64) (result i64)))
  (type (;3;) (func (param i64) (result i64)))
  (type (;4;) (func (param i64)))
  (type (;5;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 4)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 5)))
  (func (;2;) (type 0) (param $x i32) (param $y i32) (result i32)
    i64.const 8
    i64.const 1
    call 1
    i64.const 9
    call 0
    local.get $x
    f32.reinterpret_i32
    local.get $y
    f32.reinterpret_i32
    f32.div
    i32.reinterpret_f32
    i32.const 2143289344
    i32.and
  )
  (func (;3;) (type 0) (param $x i32) (param $y i32) (result i32)
    i64.const 8
    i64.const 1
    call 1
    i64.const 9
    call 0
    local.get $x
    f32.reinterpret_i32
    local.get $y
    f32.reinterpret_i32
    f32.div
    i32.reinterpret_f32
    i32.const 2147483647
    i32.and
  )
  (func (;4;) (type 1) (param $x i32) (result i32)
    i64.const 4
    i64.const 0
    call 1
    i64.const 5
    call 0
    local.get $x
    f32.reinterpret_i32
    f32.neg
    i32.reinterpret_f32
  )
  (func (;5;) (type 2) (param $x i64) (param $y i64) (result i64)
    i64.const 16
    i64.const 1
    call 1
    i64.const 9
    call 0
    local.get $x
    f64.reinterpret_i64
    local.get $y
    f64.reinterpret_i64
    f64.div
    i64.reinterpret_f64
    i64.const 9221120237041090560
    i64.and
  )
  (func (;6;) (type 2) (param $x i64) (param $y i64) (result i64)
    i64.const 16
    i64.const 1
    call 1
    i64.const 9
    call 0
    local.get $x
    f64.reinterpret_i64
    local.get $y
    f64.reinterpret_i64
    f64.div
    i64.reinterpret_f64
    i64.const 9223372036854775807
    i64.and
  )
  (func (;7;) (type 3) (param $x i64) (result i64)
    i64.const 8
    i64.const 0
    call 1
    i64.const 5
    call 0
    local.get $x
    f64.reinterpret_i64
    f64.neg
    i64.reinterpret_f64
  )
  (func (;8;) (type 1) (param $x i32) (result i32)
    i64.const 8
    i64.const 0
    call 1
    i64.const 8
    call 0
    local.get $x
    f32.reinterpret_i32
    f32.const 0x0p+0 (;=0;)
    f32.sub
    i32.reinterpret_f32
    i32.const 2143289344
    i32.and
  )
  (func (;9;) (type 1) (param $x i32) (result i32)
    i64.const 8
    i64.const 0
    call 1
    i64.const 8
    call 0
    f32.const -0x0p+0 (;=-0;)
    local.get $x
    f32.reinterpret_i32
    f32.sub
    i32.reinterpret_f32
    i32.const 2143289344
    i32.and
  )
  (func (;10;) (type 1) (param $x i32) (result i32)
    i64.const 8
    i64.const 0
    call 1
    i64.const 8
    call 0
    local.get $x
    f32.reinterpret_i32
    f32.const 0x1p+0 (;=1;)
    f32.mul
    i32.reinterpret_f32
    i32.const 2143289344
    i32.and
  )
  (func (;11;) (type 1) (param $x i32) (result i32)
    i64.const 8
    i64.const 0
    call 1
    i64.const 8
    call 0
    f32.const -0x1p+0 (;=-1;)
    local.get $x
    f32.reinterpret_i32
    f32.mul
    i32.reinterpret_f32
    i32.const 2143289344
    i32.and
  )
  (func (;12;) (type 1) (param $x i32) (result i32)
    i64.const 8
    i64.const 0
    call 1
    i64.const 8
    call 0
    local.get $x
    f32.reinterpret_i32
    f32.const 0x1p+0 (;=1;)
    f32.div
    i32.reinterpret_f32
    i32.const 2143289344
    i32.and
  )
  (func (;13;) (type 1) (param $x i32) (result i32)
    i64.const 8
    i64.const 0
    call 1
    i64.const 8
    call 0
    local.get $x
    f32.reinterpret_i32
    f32.const -0x1p+0 (;=-1;)
    f32.div
    i32.reinterpret_f32
    i32.const 2143289344
    i32.and
  )
  (func (;14;) (type 3) (param $x i64) (result i64)
    i64.const 16
    i64.const 0
    call 1
    i64.const 8
    call 0
    local.get $x
    f64.reinterpret_i64
    f64.const 0x0p+0 (;=0;)
    f64.sub
    i64.reinterpret_f64
    i64.const 9221120237041090560
    i64.and
  )
  (func (;15;) (type 3) (param $x i64) (result i64)
    i64.const 16
    i64.const 0
    call 1
    i64.const 8
    call 0
    f64.const -0x0p+0 (;=-0;)
    local.get $x
    f64.reinterpret_i64
    f64.sub
    i64.reinterpret_f64
    i64.const 9221120237041090560
    i64.and
  )
  (func (;16;) (type 3) (param $x i64) (result i64)
    i64.const 16
    i64.const 0
    call 1
    i64.const 8
    call 0
    local.get $x
    f64.reinterpret_i64
    f64.const 0x1p+0 (;=1;)
    f64.mul
    i64.reinterpret_f64
    i64.const 9221120237041090560
    i64.and
  )
  (func (;17;) (type 3) (param $x i64) (result i64)
    i64.const 16
    i64.const 0
    call 1
    i64.const 8
    call 0
    f64.const -0x1p+0 (;=-1;)
    local.get $x
    f64.reinterpret_i64
    f64.mul
    i64.reinterpret_f64
    i64.const 9221120237041090560
    i64.and
  )
  (func (;18;) (type 3) (param $x i64) (result i64)
    i64.const 16
    i64.const 0
    call 1
    i64.const 8
    call 0
    local.get $x
    f64.reinterpret_i64
    f64.const 0x1p+0 (;=1;)
    f64.div
    i64.reinterpret_f64
    i64.const 9221120237041090560
    i64.and
  )
  (func (;19;) (type 3) (param $x i64) (result i64)
    i64.const 16
    i64.const 0
    call 1
    i64.const 8
    call 0
    local.get $x
    f64.reinterpret_i64
    f64.const -0x1p+0 (;=-1;)
    f64.div
    i64.reinterpret_f64
    i64.const 9221120237041090560
    i64.and
  )
  (func (;20;) (type 1) (param $x i32) (result i32)
    i64.const 8
    i64.const 0
    call 1
    i64.const 8
    call 0
    local.get $x
    f32.reinterpret_i32
    f64.promote_f32
    f32.demote_f64
    i32.reinterpret_f32
    i32.const 2143289344
    i32.and
  )
  (export "f32.arithmetic_nan_bitpattern" (func 2))
  (export "f32.canonical_nan_bitpattern" (func 3))
  (export "f32.nonarithmetic_nan_bitpattern" (func 4))
  (export "f64.arithmetic_nan_bitpattern" (func 5))
  (export "f64.canonical_nan_bitpattern" (func 6))
  (export "f64.nonarithmetic_nan_bitpattern" (func 7))
  (export "f32.no_fold_sub_zero" (func 8))
  (export "f32.no_fold_neg0_sub" (func 9))
  (export "f32.no_fold_mul_one" (func 10))
  (export "f32.no_fold_neg1_mul" (func 11))
  (export "f32.no_fold_div_one" (func 12))
  (export "f32.no_fold_div_neg1" (func 13))
  (export "f64.no_fold_sub_zero" (func 14))
  (export "f64.no_fold_neg0_sub" (func 15))
  (export "f64.no_fold_mul_one" (func 16))
  (export "f64.no_fold_neg1_mul" (func 17))
  (export "f64.no_fold_div_one" (func 18))
  (export "f64.no_fold_div_neg1" (func 19))
  (export "no_fold_promote_demote" (func 20))
)
(assert_return (invoke "f32.arithmetic_nan_bitpattern" (i32.const 0x7f803210) (i32.const 0x7f803210)) (i32.const 0x7fc00000))
(assert_return (invoke "f32.canonical_nan_bitpattern" (i32.const 0) (i32.const 0)) (i32.const 0x7fc00000))
(assert_return (invoke "f32.canonical_nan_bitpattern" (i32.const 0x7fc00000) (i32.const 0x7fc00000)) (i32.const 0x7fc00000))
(assert_return (invoke "f32.canonical_nan_bitpattern" (i32.const 0xffc00000) (i32.const 0x7fc00000)) (i32.const 0x7fc00000))
(assert_return (invoke "f32.canonical_nan_bitpattern" (i32.const 0x7fc00000) (i32.const 0xffc00000)) (i32.const 0x7fc00000))
(assert_return (invoke "f32.canonical_nan_bitpattern" (i32.const 0xffc00000) (i32.const 0xffc00000)) (i32.const 0x7fc00000))
(assert_return (invoke "f32.nonarithmetic_nan_bitpattern" (i32.const 0x7fc03210)) (i32.const 0xffc03210))
(assert_return (invoke "f32.nonarithmetic_nan_bitpattern" (i32.const 0xffc03210)) (i32.const 0x7fc03210))
(assert_return (invoke "f32.nonarithmetic_nan_bitpattern" (i32.const 0x7f803210)) (i32.const 0xff803210))
(assert_return (invoke "f32.nonarithmetic_nan_bitpattern" (i32.const 0xff803210)) (i32.const 0x7f803210))
(assert_return (invoke "f64.arithmetic_nan_bitpattern" (i64.const 0x7ff0000000003210) (i64.const 0x7ff0000000003210)) (i64.const 0x7ff8000000000000))
(assert_return (invoke "f64.canonical_nan_bitpattern" (i64.const 0) (i64.const 0)) (i64.const 0x7ff8000000000000))
(assert_return (invoke "f64.canonical_nan_bitpattern" (i64.const 0x7ff8000000000000) (i64.const 0x7ff8000000000000)) (i64.const 0x7ff8000000000000))
(assert_return (invoke "f64.canonical_nan_bitpattern" (i64.const 0xfff8000000000000) (i64.const 0x7ff8000000000000)) (i64.const 0x7ff8000000000000))
(assert_return (invoke "f64.canonical_nan_bitpattern" (i64.const 0x7ff8000000000000) (i64.const 0xfff8000000000000)) (i64.const 0x7ff8000000000000))
(assert_return (invoke "f64.canonical_nan_bitpattern" (i64.const 0xfff8000000000000) (i64.const 0xfff8000000000000)) (i64.const 0x7ff8000000000000))
(assert_return (invoke "f64.nonarithmetic_nan_bitpattern" (i64.const 0x7ff8000000003210)) (i64.const 0xfff8000000003210))
(assert_return (invoke "f64.nonarithmetic_nan_bitpattern" (i64.const 0xfff8000000003210)) (i64.const 0x7ff8000000003210))
(assert_return (invoke "f64.nonarithmetic_nan_bitpattern" (i64.const 0x7ff0000000003210)) (i64.const 0xfff0000000003210))
(assert_return (invoke "f64.nonarithmetic_nan_bitpattern" (i64.const 0xfff0000000003210)) (i64.const 0x7ff0000000003210))
(assert_return (invoke "f32.no_fold_sub_zero" (i32.const 0x7fa00000)) (i32.const 0x7fc00000))
(assert_return (invoke "f32.no_fold_neg0_sub" (i32.const 0x7fa00000)) (i32.const 0x7fc00000))
(assert_return (invoke "f32.no_fold_mul_one" (i32.const 0x7fa00000)) (i32.const 0x7fc00000))
(assert_return (invoke "f32.no_fold_neg1_mul" (i32.const 0x7fa00000)) (i32.const 0x7fc00000))
(assert_return (invoke "f32.no_fold_div_one" (i32.const 0x7fa00000)) (i32.const 0x7fc00000))
(assert_return (invoke "f32.no_fold_div_neg1" (i32.const 0x7fa00000)) (i32.const 0x7fc00000))
(assert_return (invoke "f64.no_fold_sub_zero" (i64.const 0x7ff4000000000000)) (i64.const 0x7ff8000000000000))
(assert_return (invoke "f64.no_fold_neg0_sub" (i64.const 0x7ff4000000000000)) (i64.const 0x7ff8000000000000))
(assert_return (invoke "f64.no_fold_mul_one" (i64.const 0x7ff4000000000000)) (i64.const 0x7ff8000000000000))
(assert_return (invoke "f64.no_fold_neg1_mul" (i64.const 0x7ff4000000000000)) (i64.const 0x7ff8000000000000))
(assert_return (invoke "f64.no_fold_div_one" (i64.const 0x7ff4000000000000)) (i64.const 0x7ff8000000000000))
(assert_return (invoke "f64.no_fold_div_neg1" (i64.const 0x7ff4000000000000)) (i64.const 0x7ff8000000000000))
(assert_return (invoke "no_fold_promote_demote" (i32.const 0x7fa00000)) (i32.const 0x7fc00000))

;; Test that IEEE 754 double precision does, in fact, compute a certain dot
;; product correctly.

(module
  (type (;0;) (func (param f64 f64 f64 f64 f64 f64 f64 f64) (result f64)))
  (type (;1;) (func (param i64)))
  (type (;2;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 1)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 2)))
  (func (;2;) (type 0) (param $x0 f64) (param $x1 f64) (param $x2 f64) (param $x3 f64) (param $y0 f64) (param $y1 f64) (param $y2 f64) (param $y3 f64) (result f64)
    i64.const 24
    i64.const 7
    call 1
    i64.const 16
    call 0
    local.get $x0
    local.get $y0
    f64.mul
    local.get $x1
    local.get $y1
    f64.mul
    f64.add
    local.get $x2
    local.get $y2
    f64.mul
    f64.add
    local.get $x3
    local.get $y3
    f64.mul
    f64.add
  )
  (func (;3;) (type 0) (param $x0 f64) (param $x1 f64) (param $x2 f64) (param $x3 f64) (param $y0 f64) (param $y1 f64) (param $y2 f64) (param $y3 f64) (result f64)
    i64.const 32
    i64.const 7
    call 1
    i64.const 16
    call 0
    local.get $x0
    local.get $y0
    f64.mul
    local.get $x1
    local.get $y1
    f64.mul
    f64.add
    local.get $x2
    local.get $y2
    f64.mul
    local.get $x3
    local.get $y3
    f64.mul
    f64.add
    f64.add
  )
  (export "dot_product_example" (func 2))
  (export "with_binary_sum_collapse" (func 3))
)
(assert_return (invoke "dot_product_example"
    (f64.const 3.2e7) (f64.const 1.0) (f64.const -1.0) (f64.const 8.0e7)
    (f64.const 4.0e7) (f64.const 1.0) (f64.const -1.0) (f64.const -1.6e7))
  (f64.const 2.0))
(assert_return (invoke "with_binary_sum_collapse"
    (f64.const 3.2e7) (f64.const 1.0) (f64.const -1.0) (f64.const 8.0e7)
    (f64.const 4.0e7) (f64.const 1.0) (f64.const -1.0) (f64.const -1.6e7))
  (f64.const 2.0))

;; http://www.vinc17.org/research/fptest.en.html#contract2fma

(module
  (type (;0;) (func (param f32 f32) (result f32)))
  (type (;1;) (func (param f64 f64) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (param $y f32) (result f32)
    i64.const 12
    i64.const 1
    call 1
    i64.const 9
    call 0
    local.get $x
    local.get $x
    f32.mul
    local.get $y
    local.get $y
    f32.mul
    f32.sub
    f32.sqrt
  )
  (func (;3;) (type 1) (param $x f64) (param $y f64) (result f64)
    i64.const 24
    i64.const 1
    call 1
    i64.const 9
    call 0
    local.get $x
    local.get $x
    f64.mul
    local.get $y
    local.get $y
    f64.mul
    f64.sub
    f64.sqrt
  )
  (export "f32.contract2fma" (func 2))
  (export "f64.contract2fma" (func 3))
)
(assert_return (invoke "f32.contract2fma" (f32.const 1.0) (f32.const 1.0)) (f32.const 0.0))
(assert_return (invoke "f32.contract2fma" (f32.const 0x1.19999ap+0) (f32.const 0x1.19999ap+0)) (f32.const 0.0))
(assert_return (invoke "f32.contract2fma" (f32.const 0x1.333332p+0) (f32.const 0x1.333332p+0)) (f32.const 0.0))
(assert_return (invoke "f64.contract2fma" (f64.const 1.0) (f64.const 1.0)) (f64.const 0.0))
(assert_return (invoke "f64.contract2fma" (f64.const 0x1.199999999999ap+0) (f64.const 0x1.199999999999ap+0)) (f64.const 0.0))
(assert_return (invoke "f64.contract2fma" (f64.const 0x1.3333333333333p+0) (f64.const 0x1.3333333333333p+0)) (f64.const 0.0))

;; Test that floating-point isn't implemented with QuickBasic for MS-DOS.
;; https://support.microsoft.com/en-us/help/42980/-complete-tutorial-to-understand-ieee-floating-point-errors

(module
  (type (;0;) (func (param f32 f32 f32) (result f32)))
  (type (;1;) (func (param f64 f64 f64) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $a f32) (param $b f32) (param $c f32) (result f32)
    i64.const 12
    i64.const 2
    call 1
    i64.const 6
    call 0
    local.get $a
    local.get $b
    local.get $c
    f32.div
    f32.sub
  )
  (func (;3;) (type 1) (param $a f64) (param $b f64) (param $c f64) (result f64)
    i64.const 24
    i64.const 2
    call 1
    i64.const 6
    call 0
    local.get $a
    local.get $b
    local.get $c
    f64.div
    f64.sub
  )
  (export "f32.division_by_small_number" (func 2))
  (export "f64.division_by_small_number" (func 3))
)
(assert_return (invoke "f32.division_by_small_number" (f32.const 112000000) (f32.const 100000) (f32.const 0.0009)) (f32.const 888888))
(assert_return (invoke "f64.division_by_small_number" (f64.const 112000000) (f64.const 100000) (f64.const 0.0009)) (f64.const 888888.8888888806))

;; Test a simple golden ratio computation.
;; http://mathworld.wolfram.com/GoldenRatio.html

(module
  (type (;0;) (func (param f32 f32 f32) (result f32)))
  (type (;1;) (func (param f64 f64 f64) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $a f32) (param $b f32) (param $c f32) (result f32)
    i64.const 12
    i64.const 2
    call 1
    i64.const 7
    call 0
    local.get $a
    local.get $b
    local.get $c
    f32.sqrt
    f32.add
    f32.mul
  )
  (func (;3;) (type 1) (param $a f64) (param $b f64) (param $c f64) (result f64)
    i64.const 24
    i64.const 2
    call 1
    i64.const 7
    call 0
    local.get $a
    local.get $b
    local.get $c
    f64.sqrt
    f64.add
    f64.mul
  )
  (export "f32.golden_ratio" (func 2))
  (export "f64.golden_ratio" (func 3))
)
(assert_return (invoke "f32.golden_ratio" (f32.const 0.5) (f32.const 1.0) (f32.const 5.0)) (f32.const 1.618034))
(assert_return (invoke "f64.golden_ratio" (f64.const 0.5) (f64.const 1.0) (f64.const 5.0)) (f64.const 1.618033988749895))

;; Test some silver means computations.
;; http://mathworld.wolfram.com/SilverRatio.html

(module
  (type (;0;) (func (param f32) (result f32)))
  (type (;1;) (func (param f64) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $n f32) (result f32)
    i64.const 16
    i64.const 0
    call 1
    i64.const 11
    call 0
    f32.const 0x1p-1 (;=0.5;)
    local.get $n
    local.get $n
    local.get $n
    f32.mul
    f32.const 0x1p+2 (;=4;)
    f32.add
    f32.sqrt
    f32.add
    f32.mul
  )
  (func (;3;) (type 1) (param $n f64) (result f64)
    i64.const 32
    i64.const 0
    call 1
    i64.const 11
    call 0
    f64.const 0x1p-1 (;=0.5;)
    local.get $n
    local.get $n
    local.get $n
    f64.mul
    f64.const 0x1p+2 (;=4;)
    f64.add
    f64.sqrt
    f64.add
    f64.mul
  )
  (export "f32.silver_means" (func 2))
  (export "f64.silver_means" (func 3))
)
(assert_return (invoke "f32.silver_means" (f32.const 0.0)) (f32.const 1.0))
(assert_return (invoke "f32.silver_means" (f32.const 1.0)) (f32.const 1.6180340))
(assert_return (invoke "f32.silver_means" (f32.const 2.0)) (f32.const 2.4142136))
(assert_return (invoke "f32.silver_means" (f32.const 3.0)) (f32.const 3.3027756))
(assert_return (invoke "f32.silver_means" (f32.const 4.0)) (f32.const 4.2360680))
(assert_return (invoke "f32.silver_means" (f32.const 5.0)) (f32.const 5.1925821))
(assert_return (invoke "f64.silver_means" (f64.const 0.0)) (f64.const 1.0))
(assert_return (invoke "f64.silver_means" (f64.const 1.0)) (f64.const 1.618033988749895))
(assert_return (invoke "f64.silver_means" (f64.const 2.0)) (f64.const 2.414213562373095))
(assert_return (invoke "f64.silver_means" (f64.const 3.0)) (f64.const 3.302775637731995))
(assert_return (invoke "f64.silver_means" (f64.const 4.0)) (f64.const 4.236067977499790))
(assert_return (invoke "f64.silver_means" (f64.const 5.0)) (f64.const 5.192582403567252))

;; Test that an f64 0.4 isn't double-rounded as via extended precision.
;; https://bugs.llvm.org/show_bug.cgi?id=11200

(module
  (type (;0;) (func (param f64 f64) (result i32)))
  (type (;1;) (func (param i64)))
  (type (;2;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 1)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 2)))
  (func (;2;) (type 0) (param $four f64) (param $ten f64) (result i32)
    i64.const 16
    i64.const 1
    call 1
    i64.const 6
    call 0
    local.get $four
    local.get $ten
    f64.div
    f64.const 0x1.999999999999ap-2 (;=0.4;)
    f64.lt
  )
  (export "point_four" (func 2))
)
(assert_return (invoke "point_four" (f64.const 4.0) (f64.const 10.0)) (i32.const 0))

;; Test an approximation function for tau; it should produces the correctly
;; rounded result after (and only after) the expected number of iterations.

(module
  (type (;0;) (func (param i32) (result f64)))
  (type (;1;) (func (param i64)))
  (type (;2;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 1)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 2)))
  (func (;2;) (type 0) (param i32) (result f64)
    (local f64 f64 f64 f64)
    i64.const 48
    i64.const 4
    call 1
    i64.const 7
    call 0
    f64.const 0x0p+0 (;=0;)
    local.set 1
    block ;; label = @1
      local.get 0
      i32.const 1
      i32.lt_s
      br_if 0 (;@1;)
      i64.const 5
      call 0
      f64.const 0x1p+0 (;=1;)
      local.set 2
      f64.const 0x0p+0 (;=0;)
      local.set 3
      loop ;; label = @2
        i64.const 44
        call 0
        local.get 1
        local.get 2
        f64.const 0x1p+3 (;=8;)
        local.get 3
        f64.const 0x1p+3 (;=8;)
        f64.mul
        local.tee 4
        f64.const 0x1p+0 (;=1;)
        f64.add
        f64.div
        f64.const 0x1p+2 (;=4;)
        local.get 4
        f64.const 0x1p+2 (;=4;)
        f64.add
        f64.div
        f64.sub
        f64.const 0x1p+1 (;=2;)
        local.get 4
        f64.const 0x1.4p+2 (;=5;)
        f64.add
        f64.div
        f64.sub
        f64.const 0x1p+1 (;=2;)
        local.get 4
        f64.const 0x1.8p+2 (;=6;)
        f64.add
        f64.div
        f64.sub
        f64.mul
        f64.add
        local.set 1
        local.get 3
        f64.const 0x1p+0 (;=1;)
        f64.add
        local.set 3
        local.get 2
        f64.const 0x1p-4 (;=0.0625;)
        f64.mul
        local.set 2
        local.get 0
        i32.const -1
        i32.add
        local.tee 0
        br_if 0 (;@2;)
        i64.const 2
        call 0
      end
    end
    i64.const 2
    call 0
    local.get 1
  )
  (export "tau" (func 2))
)
(assert_return (invoke "tau" (i32.const 10)) (f64.const 0x1.921fb54442d14p+2))
(assert_return (invoke "tau" (i32.const 11)) (f64.const 0x1.921fb54442d18p+2))

;; Test that y < 0 ? x : (x + 1) is not folded to x + (y < 0).

(module
  (type (;0;) (func (param f32 f32) (result f32)))
  (type (;1;) (func (param f64 f64) (result f64)))
  (type (;2;) (func (param i64)))
  (type (;3;) (func (param i64 i64)))
  (import "spectest" "finite_wasm_gas" (func (;0;) (type 2)))
  (import "spectest" "finite_wasm_stack" (func (;1;) (type 3)))
  (func (;2;) (type 0) (param $x f32) (param $y f32) (result f32)
    i64.const 16
    i64.const 1
    call 1
    i64.const 9
    call 0
    local.get $x
    local.get $x
    f32.const 0x1p+0 (;=1;)
    f32.add
    local.get $y
    f32.const 0x0p+0 (;=0;)
    f32.lt
    select
  )
  (func (;3;) (type 1) (param $x f64) (param $y f64) (result f64)
    i64.const 32
    i64.const 1
    call 1
    i64.const 9
    call 0
    local.get $x
    local.get $x
    f64.const 0x1p+0 (;=1;)
    f64.add
    local.get $y
    f64.const 0x0p+0 (;=0;)
    f64.lt
    select
  )
  (export "f32.no_fold_conditional_inc" (func 2))
  (export "f64.no_fold_conditional_inc" (func 3))
)
(assert_return (invoke "f32.no_fold_conditional_inc" (f32.const -0.0) (f32.const -1.0)) (f32.const -0.0))
(assert_return (invoke "f64.no_fold_conditional_inc" (f64.const -0.0) (f64.const -1.0)) (f64.const -0.0))
